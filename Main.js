// Generated by Haxe 4.1.4
(function ($hx_exports, $global) { "use strict";
class Bitboard {
	constructor(l,m,u) {
		if(u == null) {
			u = 0;
		}
		if(m == null) {
			m = 0;
		}
		if(l == null) {
			l = 0;
		}
		this.needCount = false;
		this.count = 0;
		this.upper = 0;
		this.middle = 0;
		this.lower = 0;
		this.lower = l;
		this.middle = m;
		this.upper = u;
	}
	Init(u,m,l) {
		if(l == null) {
			l = 0;
		}
		if(m == null) {
			m = 0;
		}
		if(u == null) {
			u = 0;
		}
		this.lower = l;
		this.middle = m;
		this.upper = u;
	}
	Clear() {
		this.lower = 0;
		this.middle = 0;
		this.upper = 0;
		this.count = 0;
		this.needCount = false;
	}
	Copy(other) {
		this.lower = other.lower;
		this.middle = other.middle;
		this.upper = other.upper;
		this.count = other.count;
		this.needCount = other.needCount;
	}
	newCOPY() {
		let newBB = new Bitboard();
		newBB.Copy(this);
		return newBB;
	}
	IsZero() {
		if(this.lower == 0 && this.middle == 0) {
			return this.upper == 0;
		} else {
			return false;
		}
	}
	IsNonZero() {
		if(!(this.lower != 0 || this.middle != 0)) {
			return this.upper != 0;
		} else {
			return true;
		}
	}
	isSet(sq) {
		if(sq < 27) {
			return (this.lower & 1 << sq) != 0;
		} else if(sq < 54) {
			return (this.middle & 1 << sq - 27) != 0;
		} else {
			return (this.upper & 1 << sq - 54) != 0;
		}
	}
	more_than_one() {
		if((this.lower & this.lower - 1) != 0 || (this.middle & this.middle - 1) != 0 || (this.upper & this.upper - 1) != 0 || this.lower != 0 && this.upper != 0 || this.lower != 0 && this.middle != 0 || this.middle != 0 && this.upper != 0) {
			return true;
		}
		return false;
	}
	PLUS(other) {
		let overflow = (this.lower & 65535) + (other.lower & 65535) >> 16;
		overflow += (this.lower >>> 16) + (other.lower >>> 16);
		this.middle += other.middle;
		this.lower += other.lower;
		if((overflow & 65536) != 0) {
			this.middle++;
		}
	}
	newPLUS(other) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.PLUS(other);
		return newBB;
	}
	MINUS(other) {
		let notLower = ~other.lower + 1;
		let notMiddle = ~other.middle;
		let overflow = (this.lower & 65535) + (notLower & 65535) >>> 16;
		overflow += (this.lower >>> 16) + (notLower >>> 16);
		this.middle += notMiddle;
		this.lower += notLower;
		if((overflow & 65536) != 0) {
			this.middle++;
		}
		this.needCount = true;
	}
	MULTI(times) {
		let _g = 0;
		let _g1 = times;
		while(_g < _g1) {
			let t = _g++;
			this.PLUS(this.newCOPY());
		}
	}
	newMULTI(times) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.MULTI(times);
		return newBB;
	}
	newMINUS(other) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.MINUS(other);
		return newBB;
	}
	LSB() {
		if(this.lower != 0) {
			return Bitboard.LeastSB(this.lower);
		}
		if(this.middle != 0) {
			return Bitboard.LeastSB(this.middle) + 27;
		}
		if(this.upper != 0) {
			return Bitboard.LeastSB(this.upper) + 54;
		}
		return -1;
	}
	OR(other) {
		this.lower |= other.lower;
		this.middle |= other.middle;
		this.upper |= other.upper;
		this.needCount = true;
	}
	newOR(other) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.OR(other);
		return newBB;
	}
	XOR(other) {
		this.lower ^= other.lower;
		this.middle ^= other.middle;
		this.upper ^= other.upper;
		this.needCount = true;
	}
	newXOR(other) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.XOR(other);
		return newBB;
	}
	PopLSB() {
		let index = -1;
		if(this.lower != 0) {
			this.count--;
			index = Bitboard.LeastSB(this.lower);
			this.lower &= this.lower - 1;
			return index;
		}
		if(this.middle != 0) {
			this.count--;
			index = 27 + Bitboard.LeastSB(this.middle);
			this.middle &= this.middle - 1;
			return index;
		}
		if(this.upper != 0) {
			this.count--;
			index = 54 + Bitboard.LeastSB(this.upper);
			this.upper &= this.upper - 1;
			return index;
		}
		return -1;
	}
	ShiftL(theShift) {
		if(theShift < 27) {
			this.upper <<= theShift;
			this.upper |= this.middle >>> 27 - theShift;
			this.middle <<= theShift;
			this.middle |= this.lower >>> 27 - theShift;
			this.lower <<= theShift;
		} else if(theShift < 54) {
			this.upper = this.middle >>> theShift - 27;
			this.upper |= this.lower >>> 54 - theShift;
			this.middle = this.lower << theShift - 27;
			this.lower = 0;
		} else {
			this.upper = this.lower << theShift - 54;
			this.lower = 0;
		}
		this.needCount = true;
	}
	newShiftL(theShift) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.ShiftL(theShift);
		return newBB;
	}
	ShiftR(theShift) {
		if(theShift < 27) {
			this.lower >>>= theShift;
			this.lower |= this.middle << 27 - theShift >>> 27 - theShift << 27 - theShift;
			this.middle >>>= theShift;
			this.middle |= this.upper << 27 - theShift >>> 27 - theShift << 27 - theShift;
			this.upper >>>= theShift;
		} else if(theShift < 54) {
			this.lower = this.middle >>> theShift - 27;
			this.lower |= this.upper << 27 - theShift >>> 27 - theShift << 27 - theShift;
			this.middle = this.upper >>> theShift - 27;
			this.upper = 0;
		} else {
			this.lower = this.upper >>> theShift - 54;
			this.middle = 0;
			this.upper = 0;
		}
		this.needCount = true;
	}
	newShiftR(theShift) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.ShiftR(theShift);
		return newBB;
	}
	SetBit(theIndex) {
		if(theIndex < 27) {
			this.lower |= 1 << theIndex;
		} else if(theIndex < 54) {
			this.middle |= 1 << theIndex - 27;
		} else {
			this.upper |= 1 << theIndex - 54;
		}
		this.needCount = true;
	}
	ClrBit(theIndex) {
		if(theIndex < 27) {
			this.lower ^= 1 << theIndex;
		} else if(theIndex < 54) {
			this.middle ^= 1 << theIndex - 27;
		} else {
			this.upper ^= 1 << theIndex - 54;
		}
		this.needCount = true;
	}
	NORM27() {
		this.lower &= 134217727;
		this.middle &= 134217727;
		this.upper &= 134217727;
		this.needCount = true;
		return this;
	}
	AND(other) {
		this.lower &= other.lower;
		this.middle &= other.middle;
		this.upper &= other.upper;
		this.needCount = true;
	}
	newAND(other) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.AND(other);
		return newBB;
	}
	NOT() {
		this.lower = ~this.lower;
		this.middle = ~this.middle;
		this.upper = ~this.upper;
		this.count = 81 - this.count;
	}
	newNOT() {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.NOT();
		return newBB;
	}
	toStringBB() {
		let s = "";
		let _g = 0;
		while(_g < 81) {
			let i = _g++;
			let f = 8 - i % 9;
			let r = i / 9 | 0;
			let sq = f * 9 + r;
			if(i % 9 == 0) {
				s += "\n";
			}
			if(this.isSet(sq)) {
				s += "1";
			} else {
				s += "0";
			}
		}
		return s;
	}
	static LeastSB(theInt) {
		let i = -1;
		if((theInt & 65535) == 0) {
			i += 16;
			theInt >>>= 16;
		}
		if((theInt & 255) == 0) {
			i += 8;
			theInt >>>= 8;
		}
		if((theInt & 15) == 0) {
			i += 4;
			theInt >>>= 4;
		}
		if((theInt & 3) == 0) {
			i += 2;
			theInt >>>= 2;
		}
		if((theInt & 1) == 0) {
			++i;
			theInt >>>= 1;
		}
		if((theInt & 1) != 0) {
			++i;
		}
		return i;
	}
	static MostSB(theInt) {
		let i = -1;
		if((theInt & -65536) != 0) {
			i += 16;
			theInt >>>= 16;
		}
		if((theInt & 65280) != 0) {
			i += 8;
			theInt >>>= 8;
		}
		if((theInt & 240) != 0) {
			i += 4;
			theInt >>>= 4;
		}
		if((theInt & 12) != 0) {
			i += 2;
			theInt >>>= 2;
		}
		if((theInt & 3) != 0) {
			++i;
			theInt >>>= 1;
		}
		if((theInt & 1) != 0) {
			++i;
		}
		return i;
	}
}
Bitboard.__name__ = true;
class BB {
	static SquareDistance(s1,s2) {
		return BB.squareDistance[s1][s2];
	}
	static FileDistance(s1,s2) {
		return util_MathUtil.abs(Types.file_of(s1) - Types.file_of(s2));
	}
	static RankDistance(s1,s2) {
		return util_MathUtil.abs(Types.rank_of(s1) - Types.rank_of(s2));
	}
	static Init() {
		haxe_Log.trace("Init::BB",{ fileName : "BB.hx", lineNumber : 64, className : "BB", methodName : "Init"});
		if(BB.initialized) {
			return;
		}
		BB.filesBB = [];
		BB.ranksBB = [];
		let _g = 0;
		while(_g < 9) {
			let i = _g++;
			BB.filesBB.push(new Bitboard(511,0,0));
			BB.filesBB[i].ShiftL(9 * i);
			BB.ranksBB.push(new Bitboard(262657,262657,262657));
			BB.ranksBB[i].ShiftL(i);
		}
		BB.enemyField1[1] = BB.ranksBB[8].newCOPY();
		BB.enemyField1[0] = BB.ranksBB[0].newCOPY();
		BB.enemyField2[1] = BB.ranksBB[8].newOR(BB.ranksBB[7]);
		BB.enemyField2[0] = BB.ranksBB[0].newOR(BB.ranksBB[1]);
		BB.enemyField3[1] = BB.enemyField2[1].newOR(BB.ranksBB[6]);
		BB.enemyField3[0] = BB.enemyField2[0].newOR(BB.ranksBB[2]);
		BB.pawnLineBB[0] = new Bitboard();
		BB.pawnLineBB[1] = new Bitboard();
		let _g1 = 0;
		while(_g1 < 82) {
			let sq = _g1++;
			Types.sqww_table[sq] = 138412288 + Types.file_of(sq) * -16776695 + Types.rank_of(sq) * -507903;
		}
		let _g2 = 0;
		while(_g2 < 81) {
			let sq1 = _g2++;
			Types.direc_table[sq1] = [];
			let _g = 0;
			let _g1 = 8;
			while(_g < _g1) {
				let dir = _g++;
				let delta = Types.DirectToDeltaWW(dir);
				let sq2 = (Types.to_sqww(sq1) | 0) + (delta | 0);
				while(Types.is_ok(sq2)) {
					Types.direc_table[sq1][Types.sqww_to_sq(sq2)] = Types.to_directions(dir);
					sq2 += delta;
				}
			}
		}
		let _g3 = 0;
		while(_g3 < 81) {
			let sq = _g3++;
			BB.squareBB[sq] = new Bitboard();
			BB.squareBB[sq].SetBit(sq);
		}
		let _g4 = 0;
		while(_g4 < 81) {
			let s1 = _g4++;
			BB.squareDistance[s1] = [];
			let _g = 0;
			while(_g < 81) {
				let s2 = _g++;
				BB.squareDistance[s1][s2] = util_MathUtil.max(BB.FileDistance(s1,s2),BB.RankDistance(s1,s2));
			}
		}
		let this1 = 0;
		let pt = this1;
		let _g5 = 0;
		let _g6 = 31;
		while(_g5 < _g6) {
			let p = _g5++;
			let this1 = p;
			pt = this1;
			BB.stepAttacksBB[pt] = [];
			let _g = 0;
			while(_g < 81) {
				let s1 = _g++;
				BB.stepAttacksBB[pt][s1] = new Bitboard();
			}
		}
		let s = 0;
		let _g7 = 0;
		let _g8 = 15;
		while(_g7 < _g8) {
			let pt = _g7++;
			BB.pseudoAttacks[pt] = [];
		}
		let _g9 = 0;
		while(_g9 < 81) {
			let s = _g9++;
			let a = BB.AttacksBB(s,new Bitboard(),5);
			BB.pseudoAttacks[5][s] = BB.AttacksBB(s,new Bitboard(),5);
			BB.pseudoAttacks[6][s] = BB.AttacksBB(s,new Bitboard(),6);
			BB.pseudoAttacks[13][s] = BB.AttacksBB(s,new Bitboard(),13);
			BB.pseudoAttacks[14][s] = BB.AttacksBB(s,new Bitboard(),14);
			BB.RookStepEffectBB[s] = BB.pseudoAttacks[6][s].newOR(BB.squareBB[s]);
			BB.BishopStepEffectBB[s] = BB.pseudoAttacks[5][s].newOR(BB.squareBB[s]);
			BB.pseudoQueenAttacks[s] = new Bitboard();
			BB.pseudoQueenAttacks[s].OR(BB.pseudoAttacks[5][s]);
			BB.pseudoQueenAttacks[s].OR(BB.pseudoAttacks[6][s]);
		}
		let _g10 = 0;
		while(_g10 < 81) {
			let s1 = _g10++;
			BB.betweenBB[s1] = [];
			BB.lineBB[s1] = [];
			let _g = 0;
			while(_g < 81) {
				let s2 = _g++;
				BB.betweenBB[s1][s2] = new Bitboard();
				BB.lineBB[s1][s2] = new Bitboard();
				if(BB.pseudoQueenAttacks[s1].newAND(BB.squareBB[s2]).IsNonZero()) {
					let deltta = (s2 - s1) / BB.SquareDistance(s1,s2) | 0;
					s = s1 + deltta;
					while(s != s2) {
						BB.betweenBB[s1][s2].OR(BB.squareBB[s]);
						s += deltta;
					}
					pt = 6;
					if(BB.pseudoAttacks[5][s1].newAND(BB.squareBB[s2]).IsNonZero()) {
						pt = 5;
					}
					BB.lineBB[s1][s2].Copy(BB.pseudoAttacks[pt][s1]);
					BB.lineBB[s1][s2].AND(BB.pseudoAttacks[pt][s2]);
					BB.lineBB[s1][s2].OR(BB.squareBB[s1]);
					BB.lineBB[s1][s2].OR(BB.squareBB[s2]);
				}
			}
		}
		let c = 0;
		let _g11 = 1;
		let _g12 = 14;
		while(_g11 < _g12) {
			let p = _g11++;
			let this1 = p;
			pt = this1;
			let _g = 0;
			while(_g < 81) {
				let s = _g++;
				let _g1 = 0;
				while(_g1 < 9) {
					let k = _g1++;
					if(BB.steps[pt][k] == 0) {
						continue;
					}
					let to = s + BB.steps[pt][k];
					if(Types.Is_SqOK(to) == false) {
						continue;
					}
					if(BB.SquareDistance(s,to) >= 3 && pt != 2) {
						continue;
					}
					BB.stepAttacksBB[Types.Make_Piece(c,pt)][s].OR(BB.squareBB[to]);
				}
			}
		}
		let c1 = 1;
		let _g13 = 1;
		let _g14 = 14;
		while(_g13 < _g14) {
			let p = _g13++;
			let this1 = p;
			pt = this1;
			let _g = 0;
			while(_g < 81) {
				let s = _g++;
				let _g1 = 0;
				while(_g1 < 9) {
					let k = _g1++;
					if(BB.steps[pt][k] == 0) {
						continue;
					}
					let to = s - BB.steps[pt][k];
					if(Types.Is_SqOK(to) == false) {
						continue;
					}
					if(BB.SquareDistance(s,to) >= 3 && pt != 2) {
						continue;
					}
					BB.stepAttacksBB[Types.Make_Piece(c1,pt)][s].OR(BB.squareBB[to]);
				}
			}
		}
		BB.LanceStepEffectBB[0] = [];
		let _g15 = 0;
		while(_g15 < 81) {
			let s = _g15++;
			BB.LanceStepEffectBB[0][s] = BB.stepAttacksBB[Types.Make_Piece(0,2)][s].newOR(BB.squareBB[s]).newAND(BB.RookStepEffectBB[s]);
		}
		BB.LanceStepEffectBB[1] = [];
		let _g16 = 0;
		while(_g16 < 81) {
			let s = _g16++;
			BB.LanceStepEffectBB[1][s] = BB.stepAttacksBB[Types.Make_Piece(1,2)][s].newOR(BB.squareBB[s]).newAND(BB.RookStepEffectBB[s]);
		}
		BB.initialized = true;
	}
	static getStepAttacksBB(pc,sq) {
		return BB.stepAttacksBB[pc][sq];
	}
	static kingEffect(sq) {
		return BB.stepAttacksBB[8][sq];
	}
	static pawnEffect(c,sq) {
		return BB.stepAttacksBB[Types.Make_Piece(c,1)][sq];
	}
	static knightEffect(c,sq) {
		return BB.stepAttacksBB[Types.Make_Piece(c,3)][sq];
	}
	static silverEffect(c,sq) {
		return BB.stepAttacksBB[Types.Make_Piece(c,4)][sq];
	}
	static goldEffect(c,sq) {
		return BB.stepAttacksBB[Types.Make_Piece(c,7)][sq];
	}
	static cross00StepEffect(sq) {
		return BB.rookStepEffect(sq).newAND(BB.kingEffect(sq));
	}
	static cross45StepEffect(sq) {
		return BB.bishopStepEffect(sq).newAND(BB.kingEffect(sq));
	}
	static rookFileEffect(sq,occupied) {
		return BB.SlidingAttack(BB.fDeltas,sq,occupied);
	}
	static lanceEffect(c,sq,occupied) {
		if(c == 0) {
			return BB.SlidingAttack(BB.nDeltas,sq,occupied);
		} else {
			return BB.SlidingAttack(BB.sDeltas,sq,occupied);
		}
	}
	static bishopEffect(sq,occupied) {
		return BB.SlidingAttack(BB.bDeltas,sq,occupied);
	}
	static rookEffect(sq,occupied) {
		return BB.SlidingAttack(BB.rDeltas,sq,occupied);
	}
	static horseEffect(sq,occupied) {
		return BB.SlidingGoldenAttack(BB.bDeltas,sq,occupied);
	}
	static dragonEffect(sq,occupied) {
		return BB.SlidingGoldenAttack(BB.rDeltas,sq,occupied);
	}
	static rookStepEffect(sq) {
		return BB.RookStepEffectBB[sq];
	}
	static bishopStepEffect(sq) {
		return BB.BishopStepEffectBB[sq];
	}
	static lanceStepEffect(c,sq) {
		return BB.LanceStepEffectBB[c][sq];
	}
	static AttacksBB(sq,occ,pt) {
		switch(pt) {
		case 2:
			return BB.SlidingAttack(BB.rDeltas,sq,occ);
		case 5:
			return BB.SlidingAttack(BB.bDeltas,sq,occ);
		case 6:
			return BB.SlidingAttack(BB.rDeltas,sq,occ);
		case 13:
			return BB.SlidingGoldenAttack(BB.bDeltas,sq,occ);
		case 14:
			return BB.SlidingGoldenAttack(BB.rDeltas,sq,occ);
		default:
			return new Bitboard();
		}
	}
	static SlidingAttack(deltas,sq,occ) {
		let attack = new Bitboard();
		let _g = 0;
		while(_g < 4) {
			let i = _g++;
			if(deltas[i] == 0) {
				return attack;
			}
			let s = sq + deltas[i];
			while(Types.Is_SqOK(s) && BB.SquareDistance(s,s - deltas[i]) == 1) {
				attack.OR(BB.squareBB[s]);
				if(occ.newAND(BB.squareBB[s]).IsNonZero()) {
					break;
				}
				s += deltas[i];
			}
		}
		return attack;
	}
	static SlidingGoldenAttack(deltas,sq,occ) {
		let attack = BB.stepAttacksBB[8][sq].newCOPY();
		let _g = 0;
		while(_g < 4) {
			let i = _g++;
			if(deltas[i] == 0) {
				return attack;
			}
			let s = sq + deltas[i];
			while(Types.Is_SqOK(s) && BB.SquareDistance(s,s - deltas[i]) == 1) {
				attack.OR(BB.squareBB[s]);
				if(occ.newAND(BB.squareBB[s]).IsNonZero()) {
					break;
				}
				s += deltas[i];
			}
		}
		return attack;
	}
	static ShiftBB(b,deltta) {
		if(deltta == -1) {
			return b.newShiftR(1);
		}
		if(deltta == 1) {
			return b.newShiftL(1);
		}
		if(deltta == -10) {
			return b.newAND(BB.filesBB[8].newNOT()).newShiftL(10);
		}
		if(deltta == -8) {
			return b.newAND(BB.filesBB[8].newNOT()).newShiftR(8);
		}
		if(deltta == 8) {
			return b.newAND(BB.filesBB[0].newNOT()).newShiftL(8);
		}
		if(deltta == 10) {
			return b.newAND(BB.filesBB[0].newNOT()).newShiftR(10);
		}
		let zero = new Bitboard();
		return zero;
	}
	static ANDsq(b,sq) {
		return b.newAND(BB.squareBB[sq]);
	}
}
BB.__name__ = true;
class Bitboard64 {
	constructor(l,u) {
		if(u == null) {
			u = 0;
		}
		if(l == null) {
			l = 0;
		}
		this.needCount = false;
		this.count = 0;
		this.upper = 0;
		this.lower = 0;
		this.lower = l;
		this.upper = u;
	}
	Clear() {
		this.lower = 0;
		this.upper = 0;
		this.count = 0;
		this.needCount = false;
	}
	Copy(other) {
		this.lower = other.lower;
		this.upper = other.upper;
		this.count = other.count;
		this.needCount = other.needCount;
	}
	newCOPY() {
		let newBB = new Bitboard64();
		newBB.Copy(this);
		return newBB;
	}
	Equals(other) {
		if(this.lower == other.lower && this.upper == other.upper) {
			return true;
		}
		return false;
	}
	Init(u,l) {
		if(l == null) {
			l = 0;
		}
		if(u == null) {
			u = 0;
		}
		this.lower = l;
		this.upper = u;
		this.needCount = true;
	}
	SetInt(theInt) {
		this.upper = 0;
		this.lower = theInt;
		this.needCount = true;
	}
	AND(other) {
		this.lower &= other.lower;
		this.upper &= other.upper;
		this.needCount = true;
	}
	newAND(other) {
		let newBB = new Bitboard64();
		newBB.Copy(this);
		newBB.AND(other);
		return newBB;
	}
	OR(other) {
		this.lower |= other.lower;
		this.upper |= other.upper;
		this.needCount = true;
	}
	newOR(other) {
		let newBB = new Bitboard64();
		newBB.Copy(this);
		newBB.OR(other);
		return newBB;
	}
	XOR(other) {
		this.lower ^= other.lower;
		this.upper ^= other.upper;
		this.needCount = true;
	}
	newXOR(other) {
		let newBB = new Bitboard64();
		newBB.Copy(this);
		newBB.XOR(other);
		return newBB;
	}
	NOT() {
		this.lower = ~this.lower;
		this.upper = ~this.upper;
		this.count = 64 - this.count;
	}
	newNOT() {
		let newBB = new Bitboard64();
		newBB.Copy(this);
		newBB.NOT();
		return newBB;
	}
	PLUS(other) {
		let overflow = (this.lower & 65535) + (other.lower & 65535) >> 16;
		overflow += (this.lower >>> 16) + (other.lower >>> 16);
		this.upper += other.upper;
		this.lower += other.lower;
		if((overflow & 65536) != 0) {
			this.upper++;
		}
		this.needCount = true;
	}
	newPLUS(other) {
		let newBB = new Bitboard64();
		newBB.Copy(this);
		newBB.PLUS(other);
		return newBB;
	}
	MINUS(other) {
		let notLower = ~other.lower + 1;
		let notUpper = ~other.upper;
		let overflow = (this.lower & 65535) + (notLower & 65535) >>> 16;
		overflow += (this.lower >>> 16) + (notLower >>> 16);
		this.upper += notUpper;
		this.lower += notLower;
		if((overflow & 65536) != 0) {
			this.upper++;
		}
		this.needCount = true;
	}
	newMINUS(other) {
		let newBB = new Bitboard64();
		newBB.Copy(this);
		newBB.MINUS(other);
		return newBB;
	}
	PopLSB() {
		let index = -1;
		if(this.lower != 0) {
			this.count--;
			index = Bitboard64.LeastSB(this.lower);
			this.lower &= this.lower - 1;
			return index;
		}
		if(this.upper != 0) {
			this.count--;
			index = 32 + Bitboard64.LeastSB(this.upper);
			this.upper &= this.upper - 1;
			return index;
		}
		return -1;
	}
	LSB() {
		if(this.lower != 0) {
			return Bitboard64.LeastSB(this.lower);
		}
		if(this.upper != 0) {
			return Bitboard64.LeastSB(this.upper) + 32;
		}
		return -1;
	}
	MSB() {
		if(this.upper != 0) {
			return Bitboard64.MostSB(this.upper) + 32;
		}
		if(this.lower != 0) {
			return Bitboard64.MostSB(this.lower);
		}
		return -1;
	}
	ShiftL(theShift) {
		if(theShift < 32) {
			this.upper <<= theShift;
			this.upper |= this.lower >>> 32 - theShift;
			this.lower <<= theShift;
		} else {
			this.upper = this.lower << theShift - 32;
			this.lower = 0;
		}
		this.needCount = true;
	}
	newShiftL(theShift) {
		let newBB = new Bitboard64();
		newBB.Copy(this);
		newBB.ShiftL(theShift);
		return newBB;
	}
	ShiftR(theShift) {
		if(theShift < 32) {
			this.lower >>>= theShift;
			this.lower |= this.upper << 32 - theShift >>> 32 - theShift << 32 - theShift;
			this.upper >>>= theShift;
		} else {
			this.lower = this.upper >>> theShift - 32;
			this.upper = 0;
		}
		this.needCount = true;
	}
	newShiftR(theShift) {
		let newBB = new Bitboard64();
		newBB.Copy(this);
		newBB.ShiftR(theShift);
		return newBB;
	}
	SetBit(theIndex) {
		if(theIndex < 32) {
			this.lower |= 1 << theIndex;
		} else {
			this.upper |= 1 << theIndex - 32;
		}
		this.needCount = true;
	}
	ClrBit(theIndex) {
		if(theIndex < 32) {
			this.lower ^= 1 << theIndex;
		} else {
			this.upper ^= 1 << theIndex - 32;
		}
		this.needCount = true;
	}
	IsSet(theIndex) {
		if(theIndex < 32) {
			if((this.lower & 1 << theIndex) != 0) {
				return true;
			}
		} else if((this.upper & 1 << theIndex - 32) != 0) {
			return true;
		}
		return false;
	}
	IsZero() {
		if(this.lower == 0 && this.upper == 0) {
			return true;
		}
		return false;
	}
	IsNonZero() {
		if(this.lower != 0 || this.upper != 0) {
			return true;
		}
		return false;
	}
	MoreThanOne() {
		if((this.lower & this.lower - 1) != 0 || (this.upper & this.upper - 1) != 0 || this.lower != 0 && this.upper != 0) {
			return true;
		}
		return false;
	}
	Count() {
		if(this.needCount) {
			this.needCount = false;
			this.count = Bitboard64.BitCount(this.upper) + Bitboard64.BitCount(this.lower);
		}
		return this.count;
	}
	MULTI(times) {
		let _g = 0;
		let _g1 = times;
		while(_g < _g1) {
			let t = _g++;
			this.PLUS(this.newCOPY());
		}
	}
	newMULTI(times) {
		let newBB = new Bitboard64();
		newBB.Copy(this);
		newBB.MULTI(times);
		return newBB;
	}
	ToString() {
		let newString = "";
		let _g = 0;
		while(_g < 64) {
			let i = _g++;
			if(this.IsSet(63 - i)) {
				newString += "1";
			} else {
				newString += "0";
			}
		}
		return newString + " " + this.Count();
	}
	toStringBB() {
		let string = "";
		let _g = 0;
		while(_g < 64) {
			let i = _g++;
			if(i > 0 && i % 8 == 0) {
				string += "\n";
			}
			let file = i % 8;
			let rank = 7 - (i >>> 3);
			if(this.IsSet(file + (rank << 3))) {
				string += "1";
			} else {
				string += "0";
			}
		}
		return string;
	}
	static LeastSB(theInt) {
		let i = -1;
		if((theInt & 65535) == 0) {
			i += 16;
			theInt >>>= 16;
		}
		if((theInt & 255) == 0) {
			i += 8;
			theInt >>>= 8;
		}
		if((theInt & 15) == 0) {
			i += 4;
			theInt >>>= 4;
		}
		if((theInt & 3) == 0) {
			i += 2;
			theInt >>>= 2;
		}
		if((theInt & 1) == 0) {
			++i;
			theInt >>>= 1;
		}
		if((theInt & 1) != 0) {
			++i;
		}
		return i;
	}
	static MostSB(theInt) {
		let i = -1;
		if((theInt & -65536) != 0) {
			i += 16;
			theInt >>>= 16;
		}
		if((theInt & 65280) != 0) {
			i += 8;
			theInt >>>= 8;
		}
		if((theInt & 240) != 0) {
			i += 4;
			theInt >>>= 4;
		}
		if((theInt & 12) != 0) {
			i += 2;
			theInt >>>= 2;
		}
		if((theInt & 3) != 0) {
			++i;
			theInt >>>= 1;
		}
		if((theInt & 1) != 0) {
			++i;
		}
		return i;
	}
	static BitCount(theInt) {
		let total = 0;
		while(theInt != 0) {
			theInt &= theInt - 1;
			++total;
		}
		return total;
	}
	static ToStringBB2(b1,b2) {
		let string = "";
		let file = 0;
		let rank = 0;
		let _g = 0;
		while(_g < 8) {
			let j = _g++;
			let _g1 = 0;
			while(_g1 < 8) {
				let i = _g1++;
				file = i;
				rank = 7 - j;
				if(b1.IsSet(file + (rank << 3))) {
					string += "1";
				} else {
					string += "0";
				}
				if(file == 7) {
					string += " ";
				}
			}
			let _g2 = 0;
			while(_g2 < 8) {
				let i = _g2++;
				file = i;
				rank = 7 - j;
				if(b2.IsSet(file + (rank << 3))) {
					string += "1";
				} else {
					string += "0";
				}
				if(file == 7) {
					string += "\n";
				}
			}
		}
		return string;
	}
	static ToStringBB8(b1,b2,b3,b4,b5,b6,b7,b8) {
		let string = "";
		let _g = 0;
		while(_g < 8) {
			let j = _g++;
			let _g1 = 0;
			while(_g1 < 8) {
				let k = _g1++;
				let bb = b1;
				if(k == 1) {
					bb = b2;
				}
				if(k == 2) {
					bb = b3;
				}
				if(k == 3) {
					bb = b4;
				}
				if(k == 4) {
					bb = b5;
				}
				if(k == 5) {
					bb = b6;
				}
				if(k == 6) {
					bb = b7;
				}
				if(k == 7) {
					bb = b8;
				}
				let _g = 0;
				while(_g < 8) {
					let i = _g++;
					let file = i;
					let rank = 7 - j;
					if(bb.IsSet(file + (rank << 3))) {
						string += "1";
					} else {
						string += "0";
					}
					if(file == 7 && k < 7) {
						string += " ";
					}
					if(file == 7 && k == 7) {
						string += "\n";
					}
				}
			}
		}
		return string;
	}
}
Bitboard64.__name__ = true;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
}
EReg.__name__ = true;
class EvalSum {
	constructor() {
		this.p = [[0,0],[0,0],[0,0]];
		this.m = [];
	}
	sum(c) {
		let scoreBoard = this.p[0][0] - this.p[1][0] + this.p[2][0];
		let scoreTurn = this.p[2][1];
		return (c == 0 ? scoreBoard : -scoreBoard) + scoreTurn;
	}
}
EvalSum.__name__ = true;
class ExtBonaPiece {
	constructor(b,w) {
		this.fb = b;
		this.fw = w;
	}
}
ExtBonaPiece.__name__ = true;
class EvalList {
	constructor() {
		this.piece_no_list_hand = [];
		this.piece_no_list_board = new Array(82);
		this.pieceListFw = new Array(40);
		this.pieceListFb = new Array(40);
		this.kpp_hand_index = [[new ExtBonaPiece(0,0),new ExtBonaPiece(1,20),new ExtBonaPiece(39,44),new ExtBonaPiece(49,54),new ExtBonaPiece(59,64),new ExtBonaPiece(79,82),new ExtBonaPiece(85,88),new ExtBonaPiece(69,74)],[new ExtBonaPiece(0,0),new ExtBonaPiece(20,1),new ExtBonaPiece(44,39),new ExtBonaPiece(54,49),new ExtBonaPiece(64,59),new ExtBonaPiece(82,79),new ExtBonaPiece(88,85),new ExtBonaPiece(74,69)]];
		this.kpp_board_index = [new ExtBonaPiece(0,0),new ExtBonaPiece(90,90 + 81),new ExtBonaPiece(90 + 81 + 81,90 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(0,0),new ExtBonaPiece(0,0),new ExtBonaPiece(90 + 81,90),new ExtBonaPiece(90 + 81 + 81 + 81,90 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(0,0)];
		let _g = 0;
		let _g1 = this.length();
		while(_g < _g1) {
			let i = _g++;
			this.pieceListFb[i] = 0;
			this.pieceListFw[i] = 0;
		}
	}
	piece_list_fb() {
		return this.pieceListFb;
	}
	piece_list_fw() {
		return this.pieceListFw;
	}
	length() {
		return 38;
	}
	put_piece(piece_no,sq,pc) {
		this.set_piece_on_board(piece_no,this.kpp_board_index[pc].fb + sq,this.kpp_board_index[pc].fw + Types.Inv(sq),sq);
	}
	put_piece_hand(piece_no,c,pt,i) {
		this.set_piece_on_hand(piece_no,this.kpp_hand_index[c][pt].fb + i,this.kpp_hand_index[c][pt].fw + i);
	}
	piece_no_of_hand(bp) {
		return this.piece_no_list_hand[bp];
	}
	piece_no_of_board(sq) {
		return this.piece_no_list_board[sq];
	}
	printPieceNo() {
		haxe_Log.trace("EvalList::print",{ fileName : "Evaluate.hx", lineNumber : 185, className : "EvalList", methodName : "printPieceNo"});
		let str = "--- print PieceNo ---";
		let _g = 0;
		while(_g < 81) {
			let i = _g++;
			if(i % 9 == 0) {
				str += "\n";
			}
			let s = this.piece_no_list_board[Types.bbToSquare[i]];
			if(isNaN(s)) {
				str += " - ";
			} else {
				str += HxOverrides.substr(" " + this.piece_no_list_board[Types.bbToSquare[i]] + " ",-3,null);
			}
		}
		haxe_Log.trace("" + str,{ fileName : "Evaluate.hx", lineNumber : 199, className : "EvalList", methodName : "printPieceNo"});
		haxe_Log.trace("piece_no_list_hand: " + Std.string(this.piece_no_list_hand),{ fileName : "Evaluate.hx", lineNumber : 200, className : "EvalList", methodName : "printPieceNo"});
	}
	set_piece_on_board(piece_no,fb,fw,sq) {
		this.pieceListFb[piece_no] = fb;
		this.pieceListFw[piece_no] = fw;
		this.piece_no_list_board[sq] = piece_no;
	}
	set_piece_on_hand(piece_no,fb,fw) {
		this.pieceListFb[piece_no] = fb;
		this.pieceListFw[piece_no] = fw;
		this.piece_no_list_hand[fb] = piece_no;
	}
}
EvalList.__name__ = true;
class DirtyPiece {
	constructor() {
		this.dirty_num = 0;
		this.pieceNo = new Array(2);
	}
}
DirtyPiece.__name__ = true;
class Evaluate {
	static load_eval() {
		Evaluate.load_eval_impl();
	}
	static load_eval_impl() {
		Evaluate.load_eval_kk();
		Evaluate.load_eval_kkp();
		Evaluate.load_eval_kpp();
	}
	static load_eval_kk() {
		let filename = "" + Evaluate.storage_path + "bin/KK_synthesized.bin";
		let request = new XMLHttpRequest();
		request.open("GET",filename,true);
		request.responseType = "arraybuffer";
		request.onload = function(e) {
			haxe_Log.trace("kk read start",{ fileName : "Evaluate.hx", lineNumber : 335, className : "Evaluate", methodName : "load_eval_kk"});
			let arrayBuffer = request.response;
			if(arrayBuffer == null) {
				haxe_Log.trace("buffer is null",{ fileName : "Evaluate.hx", lineNumber : 338, className : "Evaluate", methodName : "load_eval_kk"});
				return;
			}
			let dataview = new DataView(arrayBuffer);
			let bytesData = new ArrayBuffer(dataview.byteLength);
			let byteSize = 4;
			let p = 0;
			haxe_Log.trace("bytesData:" + Std.string(bytesData) + " arrayBuffer:" + arrayBuffer.byteLength,{ fileName : "Evaluate.hx", lineNumber : 346, className : "Evaluate", methodName : "load_eval_kk"});
			let _g = 0;
			while(_g < 81) {
				let i = _g++;
				let _g1 = 0;
				while(_g1 < 81) {
					let j = _g1++;
					Evaluate.kk[i][j][0] = dataview.getInt32(p * byteSize,true);
					++p;
					Evaluate.kk[i][j][1] = dataview.getInt32(p * byteSize,true);
					++p;
				}
			}
			haxe_Log.trace("kk read end",{ fileName : "Evaluate.hx", lineNumber : 358, className : "Evaluate", methodName : "load_eval_kk"});
		};
		request.send(null);
	}
	static load_eval_kkp() {
		let filename = "" + Evaluate.storage_path + "bin/KKP_synthesized.bin";
		haxe_Log.trace("kkp filename " + filename,{ fileName : "Evaluate.hx", lineNumber : 365, className : "Evaluate", methodName : "load_eval_kkp"});
		let request = new XMLHttpRequest();
		request.open("GET",filename,true);
		request.responseType = "arraybuffer";
		request.onload = function(e) {
			haxe_Log.trace("kkp read start",{ fileName : "Evaluate.hx", lineNumber : 370, className : "Evaluate", methodName : "load_eval_kkp"});
			let arrayBuffer = request.response;
			if(arrayBuffer == null) {
				haxe_Log.trace("buffer is null",{ fileName : "Evaluate.hx", lineNumber : 373, className : "Evaluate", methodName : "load_eval_kkp"});
				return;
			}
			let dataview = new DataView(arrayBuffer);
			let bytesData = new ArrayBuffer(dataview.byteLength);
			let byteSize = 4;
			let p = 0;
			let _g = 0;
			while(_g < 81) {
				let i = _g++;
				let _g1 = 0;
				while(_g1 < 81) {
					let j = _g1++;
					let _g = 0;
					let _g2 = 90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81;
					while(_g < _g2) {
						let m = _g++;
						Evaluate.kkp[i][j][m][0] = dataview.getInt32(p * byteSize,true);
						++p;
						Evaluate.kkp[i][j][m][1] = dataview.getInt32(p * byteSize,true);
						++p;
					}
				}
			}
			haxe_Log.trace("kkp read end p = " + p,{ fileName : "Evaluate.hx", lineNumber : 394, className : "Evaluate", methodName : "load_eval_kkp"});
			haxe_Log.trace("f_pawn " + 90,{ fileName : "Evaluate.hx", lineNumber : 395, className : "Evaluate", methodName : "load_eval_kkp"});
			haxe_Log.trace("kkp[44][36][90+59][0] = " + Evaluate.kkp[44][36][149][0],{ fileName : "Evaluate.hx", lineNumber : 396, className : "Evaluate", methodName : "load_eval_kkp"});
			haxe_Log.trace("kkp[44][36][90+59][1] = " + Evaluate.kkp[44][36][149][1],{ fileName : "Evaluate.hx", lineNumber : 397, className : "Evaluate", methodName : "load_eval_kkp"});
		};
		request.send(null);
	}
	static load_eval_kpp() {
		let filename = "" + Evaluate.storage_path + "bin/KPP_synthesized.bin";
		let request = new XMLHttpRequest();
		request.open("GET",filename,true);
		request.responseType = "arraybuffer";
		request.onload = function(e) {
			haxe_Log.trace("kpp read start",{ fileName : "Evaluate.hx", lineNumber : 408, className : "Evaluate", methodName : "load_eval_kpp"});
			let arrayBuffer = request.response;
			if(arrayBuffer == null || arrayBuffer.byteLength < 1000) {
				haxe_Log.trace("kpp buffer is null",{ fileName : "Evaluate.hx", lineNumber : 411, className : "Evaluate", methodName : "load_eval_kpp"});
				return;
			}
			let dataview = new DataView(arrayBuffer);
			let bytesData = new ArrayBuffer(dataview.byteLength);
			let byteSize = 2;
			let p = 0;
			let _g = 0;
			while(_g < 81) {
				let i = _g++;
				let _g1 = 0;
				let _g2 = 90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81;
				while(_g1 < _g2) {
					let j = _g1++;
					let _g = 0;
					let _g2 = 90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81;
					while(_g < _g2) {
						let k = _g++;
						Evaluate.kpp[i][j][k] = dataview.getInt16(p * byteSize,true);
						++p;
					}
				}
			}
			haxe_Log.trace("kpp read end p = " + p,{ fileName : "Evaluate.hx", lineNumber : 426, className : "Evaluate", methodName : "load_eval_kpp"});
		};
		request.send(null);
	}
	static Init() {
		haxe_Log.trace("Evaluate::Init fe_end:" + (90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81) + " fe_end2:" + (90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),{ fileName : "Evaluate.hx", lineNumber : 432, className : "Evaluate", methodName : "Init"});
		let this1 = new Array(81);
		Evaluate.kk = this1;
		let _g = 0;
		while(_g < 81) {
			let i = _g++;
			let this1 = Evaluate.kk;
			let this2 = new Array(81);
			this1[i] = this2;
			let _g1 = 0;
			while(_g1 < 81) {
				let j = _g1++;
				let this1 = Evaluate.kk[i];
				let this2 = new Array(2);
				this1[j] = this2;
				Evaluate.kk[i][j][0] = 0;
				Evaluate.kk[i][j][1] = 0;
			}
		}
		let this2 = new Array(81);
		Evaluate.kkp = this2;
		let _g1 = 0;
		while(_g1 < 81) {
			let i = _g1++;
			let this1 = Evaluate.kkp;
			let this2 = new Array(81);
			this1[i] = this2;
			let _g = 0;
			while(_g < 81) {
				let j = _g++;
				let this1 = Evaluate.kkp[i];
				let this2 = new Array(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81);
				this1[j] = this2;
				let _g1 = 0;
				let _g2 = 90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81;
				while(_g1 < _g2) {
					let m = _g1++;
					let this1 = Evaluate.kkp[i][j];
					let this2 = new Array(2);
					this1[m] = this2;
					Evaluate.kkp[i][j][m][0] = 0;
					Evaluate.kkp[i][j][m][1] = 0;
				}
			}
		}
		let this3 = new Array(81);
		Evaluate.kpp = this3;
		let _g2 = 0;
		while(_g2 < 81) {
			let i = _g2++;
			let this1 = Evaluate.kpp;
			let this2 = new Array(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81);
			this1[i] = this2;
			let _g = 0;
			let _g1 = 90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81;
			while(_g < _g1) {
				let j = _g++;
				let this1 = Evaluate.kpp[i];
				let this2 = new Array(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81);
				this1[j] = this2;
				let _g1 = 0;
				let _g2 = 90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81;
				while(_g1 < _g2) {
					let k = _g1++;
					Evaluate.kpp[i][j][k] = 0;
				}
			}
		}
		Evaluate.load_eval();
		let _g3 = 0;
		while(_g3 < 9) {
			let i = _g3++;
			Evaluate.our_effect_value[i] = 69632 / (i + 1) | 0;
			Evaluate.their_effect_value[i] = 98304 / (i + 1) | 0;
		}
	}
	static compute_eval_impl(pos) {
		let sq_bk = pos.king_square(0);
		let sq_wk = pos.king_square(1);
		let ppkppb = Evaluate.kpp[sq_bk];
		let ppkppw = Evaluate.kpp[Types.Inv(sq_wk)];
		let pos_ = pos;
		let length = pos_.eval_list().length();
		let list_fb = pos_.eval_list().piece_list_fb();
		let list_fw = pos_.eval_list().piece_list_fw();
		let k0;
		let k1;
		let l0;
		let l1;
		let sum = new EvalSum();
		let st = pos.state();
		let score = st.materialValue;
		sum.p[0][0] = sum.p[1][0] = 0;
		sum.p[2][0] = Evaluate.kk[sq_bk][sq_wk][0];
		sum.p[2][1] = Evaluate.kk[sq_bk][sq_wk][1];
		let dp = st.dirtyPiece;
		let k = dp.dirty_num;
		let this1 = new Array(2);
		let effects = this1;
		let dirty = dp.pieceNo[0];
		let _g = 0;
		let _g1 = length;
		while(_g < _g1) {
			let i = _g++;
			k0 = list_fb[i];
			k1 = list_fw[i];
			let pkppb = ppkppb[k0];
			let pkppw = ppkppw[k1];
			let _g1 = 0;
			let _g2 = i;
			while(_g1 < _g2) {
				let j = _g1++;
				l0 = list_fb[j];
				l1 = list_fw[j];
				sum.p[0][0] += pkppb[l0];
				sum.p[1][0] += pkppw[l1];
			}
			sum.p[2][0] += Evaluate.kkp[sq_bk][sq_wk][k0][0];
			sum.p[2][1] += Evaluate.kkp[sq_bk][sq_wk][k1][1];
		}
		sum.p[2][0] += score * 32;
		st.sum = sum;
	}
	static compute_eval(pos) {
		Evaluate.compute_eval_impl(pos);
		return pos.state().sum.sum(pos.side_to_move()) / 32 | 0;
	}
	static evaluateBody(pos) {
		Evaluate.compute_eval_impl(pos);
	}
	static DoEvaluate(pos,doTrace) {
		Evaluate.compute_eval(pos);
		let st = pos.state();
		let sum = st.sum;
		return sum.sum(pos.side_to_move()) / 32 | 0;
	}
}
Evaluate.__name__ = true;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
class ByteBoard {
	constructor() {
		this.e = new Array(82);
		this.clear();
	}
	clear() {
		let _g = 0;
		while(_g < 82) {
			let i = _g++;
			this.e[i] = 0;
		}
	}
	effect(sq) {
		return this.e[sq];
	}
}
ByteBoard.__name__ = true;
class WordBoard {
	constructor() {
		this.le16 = new Array(82);
		this.clear();
	}
	clear() {
		let _g = 0;
		while(_g < 82) {
			let i = _g++;
			this.le16[i] = new LongEffect16();
		}
	}
	long_effect16(sq) {
		return this.le16[sq].u16;
	}
}
WordBoard.__name__ = true;
class LongEffect16 {
	constructor() {
	}
	getDir(c) {
		if(c == 0) {
			return this.u16 & 255;
		} else {
			return this.u16 >>> 8;
		}
	}
	setDirXOR(c,dir) {
		if(c == 0) {
			this.u16 ^= dir;
		} else {
			this.u16 ^= dir << 8;
		}
	}
}
LongEffect16.__name__ = true;
class LongEffect {
	static long_effect16_of(pc) {
		return LongEffect.long_effect16_table[pc];
	}
	static init(pos) {
		haxe_Log.trace("Longeffect::init",{ fileName : "LongEffect.hx", lineNumber : 87, className : "LongEffect", methodName : "init"});
		pos.board_effect[0] = new ByteBoard();
		pos.board_effect[1] = new ByteBoard();
		pos.long_effect = new WordBoard();
	}
	static calc_effect(pos) {
		let board_effect = pos.board_effect;
		let long_effect = pos.long_effect;
		board_effect[0].clear();
		board_effect[1].clear();
		long_effect.clear();
		let b = pos.PiecesAll().newCOPY();
		while(b.IsNonZero()) {
			let sq = b.PopLSB();
			let pc = pos.piece_on(sq);
			let effect = LongEffect.effects_from(pc,sq,pos.pieces());
			let c = Types.color_of(pc);
			let eb = effect.newCOPY();
			while(eb.IsNonZero()) {
				let to = eb.PopLSB();
				pos.ADD_BOARD_EFFECT(c,to,1);
			}
			if(Types.has_long_effect(pc)) {
				if(Types.type_of(pc) != 2) {
					let this1 = pc & -9;
					effect = LongEffect.effects_from(this1,sq,pos.pieces());
				}
				eb = effect.newCOPY();
				while(eb.IsNonZero()) {
					let to = eb.PopLSB();
					let dir = Types.directions_of(sq,to);
					long_effect.le16[to].setDirXOR(c,dir);
				}
			}
		}
		LongEffect.printBoardEffect(board_effect,0);
		LongEffect.printBoardEffect(board_effect,1);
		LongEffect.printLongEffect(long_effect);
	}
	static printBoardEffect(board_effect,c) {
		let out = "--- BoardEffect c:" + c;
		let _g = 0;
		while(_g < 9) {
			let r = _g++;
			out += "\n";
			let f = 8;
			while(f >= 0) {
				let sq = Types.Square(f,r);
				let e = board_effect[c].e[sq];
				out += " " + e;
				--f;
			}
		}
		haxe_Log.trace(out,{ fileName : "LongEffect.hx", lineNumber : 153, className : "LongEffect", methodName : "printBoardEffect"});
	}
	static printLongEffect(long_effect) {
		let out = "--- LongEffect";
		let _g = 0;
		while(_g < 9) {
			let r = _g++;
			out += "\n";
			let f = 8;
			while(f >= 0) {
				let sq = Types.Square(f,r);
				let e = long_effect.le16[sq];
				out += "[";
				let e0 = e.getDir(0);
				let e1 = e.getDir(1);
				out += "" + e0 + ":" + e1;
				out += "]";
				--f;
			}
		}
		haxe_Log.trace(out,{ fileName : "LongEffect.hx", lineNumber : 172, className : "LongEffect", methodName : "printLongEffect"});
	}
	static short_effects_from(pc,sq) {
		switch(pc) {
		case 1:
			return BB.pawnEffect(0,sq);
		case 2:case 5:case 6:
			return BB.ZERO_BB;
		case 3:
			return BB.knightEffect(0,sq);
		case 4:
			return BB.silverEffect(0,sq);
		case 7:case 9:case 10:case 11:case 12:
			return BB.goldEffect(0,sq);
		case 13:case 29:
			return BB.cross00StepEffect(sq);
		case 17:
			return BB.pawnEffect(1,sq);
		case 19:
			return BB.knightEffect(1,sq);
		case 20:
			return BB.silverEffect(1,sq);
		case 18:case 21:case 22:
			return BB.ZERO_BB;
		case 8:case 24:
			return BB.kingEffect(sq);
		case 23:case 25:case 26:case 27:case 28:
			return BB.goldEffect(1,sq);
		case 14:case 30:
			return BB.cross45StepEffect(sq);
		default:
			return BB.ZERO_BB;
		}
	}
	static UPDATE_LONG_EFFECT_FROM_(pos,EFFECT_FUNC,to,dir_bw_us,dir_bw_others,p) {
		let Us = pos.sideToMove;
		let sq = 0;
		let dir_bw = dir_bw_us ^ dir_bw_others;
		let toww = Types.to_sqww(to);
		while(dir_bw > 0) {
			let dir = Bitboard.LeastSB(dir_bw) & 7;
			let value = 1 << dir | 1 << dir + 8;
			value &= dir_bw;
			dir_bw &= ~value;
			let delta = Types.DirectToDeltaWW(dir);
			let the_same_color = Us == 0 && (value & 255) != 0 || Us == 1 && (value & 65280) != 0;
			let e1 = (dir_bw_us & value) != 0 ? p : the_same_color ? -p : 0;
			let not_the_same = Us == 0 && (value & 65280) != 0 || Us == 1 && (value & 255) != 0;
			let e2 = not_the_same ? -p : 0;
			let toww2 = toww;
			while(true) {
				toww2 += delta;
				if(!Types.is_ok(toww2)) {
					break;
				}
				sq = Types.sqww_to_sq(toww2);
				pos.long_effect.le16[sq].u16 ^= value;
				EFFECT_FUNC(pos,Us,sq,e1,e2);
				if(!(pos.piece_on(sq) == 0)) {
					break;
				}
			}
		}
	}
	static UPDATE_LONG_EFFECT_FROM(pos,to,dir_bw_us,dir_bw_others,p) {
		LongEffect.UPDATE_LONG_EFFECT_FROM_(pos,LongEffect.ADD_BOARD_EFFECT_BOTH,to,dir_bw_us,dir_bw_others,p);
	}
	static UPDATE_LONG_EFFECT_FROM_REWIND(pos,to,dir_bw_us,dir_bw_others,p) {
		LongEffect.UPDATE_LONG_EFFECT_FROM_(pos,LongEffect.ADD_BOARD_EFFECT_BOTH_REWIND,to,dir_bw_us,dir_bw_others,p);
	}
	static update_by_capturing_piece(pos,from,to,moved_pc,moved_after_pc,captured_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let long_effect = pos.long_effect;
		let dec_target = LongEffect.short_effects_from(moved_pc,from).newCOPY();
		let inc_target = LongEffect.short_effects_from(moved_after_pc,to).newCOPY();
		let and_target = inc_target.newAND(dec_target);
		inc_target.XOR(and_target);
		dec_target.XOR(and_target);
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Us,sq,1);
		}
		while(dec_target.IsNonZero()) {
			let sq = dec_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Us,sq,-1);
		}
		dec_target = LongEffect.short_effects_from(captured_pc,to).newCOPY();
		while(dec_target.IsNonZero()) {
			let sq = dec_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Types.OppColour(Us),sq,-1);
		}
		let dir = Types.directions_of(from,to);
		let dir_mask;
		if(dir != 0) {
			let dir_cont = 1 << 7 - Bitboard.LeastSB(dir);
			dir_mask = ~(dir_cont | dir_cont << 8);
		} else {
			dir_mask = 65535;
		}
		let dir_bw_us = LongEffect.long_effect16_of(moved_pc) & dir_mask;
		let dir_bw_others = pos.long_effect.long_effect16(from) & dir_mask;
		LongEffect.UPDATE_LONG_EFFECT_FROM(pos,from,dir_bw_us,dir_bw_others,-1);
		dir_bw_us = LongEffect.long_effect16_of(moved_after_pc);
		dir_bw_others = LongEffect.long_effect16_of(captured_pc);
		LongEffect.UPDATE_LONG_EFFECT_FROM(pos,to,dir_bw_us,dir_bw_others,1);
	}
	static update_by_no_capturing_piece(pos,from,to,moved_pc,moved_after_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let long_effect = pos.long_effect;
		let dec_target = LongEffect.short_effects_from(moved_pc,from).newCOPY();
		let inc_target = LongEffect.short_effects_from(moved_after_pc,to).newCOPY();
		let and_target = inc_target.newAND(dec_target);
		inc_target.XOR(and_target);
		dec_target.XOR(and_target);
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Us,sq,1);
		}
		while(dec_target.IsNonZero()) {
			let sq = dec_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Us,sq,-1);
		}
		let dir = Types.directions_of(from,to);
		let dir_mask = 0;
		if(dir != 0) {
			let lsb = Bitboard.LeastSB(dir);
			let dir_cont = 1 << 7 - lsb;
			dir_mask = ~(dir_cont | dir_cont << 8);
		} else {
			dir_mask = 65535;
		}
		let dir_bw_us = LongEffect.long_effect16_of(moved_pc) & dir_mask;
		let dir_bw_others = pos.long_effect.long_effect16(from) & dir_mask;
		LongEffect.UPDATE_LONG_EFFECT_FROM(pos,from,dir_bw_us,dir_bw_others,-1);
		dir_bw_us = LongEffect.long_effect16_of(moved_after_pc);
		dir_bw_others = pos.long_effect.long_effect16(to);
		LongEffect.UPDATE_LONG_EFFECT_FROM(pos,to,dir_bw_us,dir_bw_others,1);
	}
	static update_by_dropping_piece(pos,to,dropped_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let inc_target = LongEffect.short_effects_from(dropped_pc,to).newCOPY();
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Us,sq,1);
		}
		let long_effect = pos.long_effect;
		let dir_bw_us = LongEffect.long_effect16_of(dropped_pc);
		let dir_bw_others = pos.long_effect.long_effect16(to);
		LongEffect.UPDATE_LONG_EFFECT_FROM(pos,to,dir_bw_us,dir_bw_others,1);
	}
	static rewind_by_dropping_piece(pos,to,dropped_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let inc_target = LongEffect.short_effects_from(dropped_pc,to).newCOPY();
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Us,sq,-1);
		}
		let long_effect = pos.long_effect;
		let dir_bw_us = LongEffect.long_effect16_of(dropped_pc);
		let dir_bw_others = pos.long_effect.long_effect16(to);
		LongEffect.UPDATE_LONG_EFFECT_FROM_REWIND(pos,to,dir_bw_us,dir_bw_others,-1);
	}
	static rewind_by_capturing_piece(pos,from,to,moved_pc,moved_after_pc,captured_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let long_effect = pos.long_effect;
		let inc_target = LongEffect.short_effects_from(moved_pc,from).newCOPY();
		let dec_target = LongEffect.short_effects_from(moved_after_pc,to).newCOPY();
		let and_target = inc_target.newAND(dec_target);
		inc_target.XOR(and_target);
		dec_target.XOR(and_target);
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Us,sq,1);
		}
		while(dec_target.IsNonZero()) {
			let sq = dec_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Us,sq,-1);
		}
		inc_target = LongEffect.short_effects_from(captured_pc,to).newCOPY();
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Types.OppColour(Us),sq,1);
		}
		let dir_bw_us = LongEffect.long_effect16_of(moved_after_pc);
		let dir_bw_others = LongEffect.long_effect16_of(captured_pc);
		LongEffect.UPDATE_LONG_EFFECT_FROM_REWIND(pos,to,dir_bw_us,dir_bw_others,-1);
		let dir = Types.directions_of(from,to);
		let dir_mask;
		if(dir != 0) {
			let dir_cont = 1 << 7 - Bitboard.LeastSB(dir);
			dir_mask = ~(dir_cont | dir_cont << 8);
		} else {
			dir_mask = 65535;
		}
		dir_bw_us = LongEffect.long_effect16_of(moved_pc) & dir_mask;
		dir_bw_others = pos.long_effect.long_effect16(from) & dir_mask;
		LongEffect.UPDATE_LONG_EFFECT_FROM_REWIND(pos,from,dir_bw_us,dir_bw_others,1);
	}
	static rewind_by_no_capturing_piece(pos,from,to,moved_pc,moved_after_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let long_effect = pos.long_effect;
		let inc_target = LongEffect.short_effects_from(moved_pc,from).newCOPY();
		let dec_target = LongEffect.short_effects_from(moved_after_pc,to).newCOPY();
		let and_target = inc_target.newAND(dec_target);
		inc_target.XOR(and_target);
		dec_target.XOR(and_target);
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Us,sq,1);
		}
		while(dec_target.IsNonZero()) {
			let sq = dec_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Us,sq,-1);
		}
		let dir_bw_us = LongEffect.long_effect16_of(moved_after_pc);
		let dir_bw_others = pos.long_effect.long_effect16(to);
		LongEffect.UPDATE_LONG_EFFECT_FROM_REWIND(pos,to,dir_bw_us,dir_bw_others,-1);
		let dir = Types.directions_of(from,to);
		let dir_mask;
		if(dir != 0) {
			let dir_cont = 1 << 7 - Bitboard.LeastSB(dir);
			dir_mask = ~(dir_cont | dir_cont << 8);
		} else {
			dir_mask = 65535;
		}
		dir_bw_us = LongEffect.long_effect16_of(moved_pc) & dir_mask;
		dir_bw_others = pos.long_effect.long_effect16(from) & dir_mask;
		LongEffect.UPDATE_LONG_EFFECT_FROM_REWIND(pos,from,dir_bw_us,dir_bw_others,1);
	}
	static effects_from(pc,sq,occ) {
		switch(pc) {
		case 1:
			return BB.pawnEffect(0,sq);
		case 2:
			return BB.lanceEffect(0,sq,occ);
		case 3:
			return BB.knightEffect(0,sq);
		case 4:
			return BB.silverEffect(0,sq);
		case 7:case 9:case 10:case 11:case 12:
			return BB.goldEffect(0,sq);
		case 13:case 29:
			return BB.horseEffect(sq,occ);
		case 17:
			return BB.pawnEffect(1,sq);
		case 18:
			return BB.lanceEffect(1,sq,occ);
		case 19:
			return BB.knightEffect(1,sq);
		case 20:
			return BB.silverEffect(1,sq);
		case 5:case 21:
			return BB.bishopEffect(sq,occ);
		case 6:case 22:
			return BB.rookEffect(sq,occ);
		case 8:case 24:
			return BB.kingEffect(sq);
		case 23:case 25:case 26:case 27:case 28:
			return BB.goldEffect(1,sq);
		case 14:case 30:
			return BB.dragonEffect(sq,occ);
		default:
			return new Bitboard();
		}
	}
	static ADD_BOARD_EFFECT_BOTH(pos,color_,sq_,e1_,e2_) {
		pos.board_effect[color_].e[sq_] += e1_;
		pos.board_effect[Types.OppColour(color_)].e[sq_] += e2_;
	}
	static ADD_BOARD_EFFECT_REWIND(pos,color_,sq_,e1_) {
		pos.board_effect[color_].e[sq_] += e1_;
	}
	static ADD_BOARD_EFFECT_BOTH_REWIND(pos,color_,sq_,e1_,e2_) {
		pos.board_effect[color_].e[sq_] += e1_;
		pos.board_effect[Types.OppColour(color_)].e[sq_] += e2_;
	}
}
LongEffect.__name__ = true;
class Main {
	static main() {
		haxe_Log.trace("Hello haxe",{ fileName : "Main.hx", lineNumber : 11, className : "Main", methodName : "main"});
		let ui = new ui_UI();
		Main.gui = ui;
	}
	static onClickCell(sq) {
		Main.gui.onClickCell(sq);
	}
	static onClickHand(pr) {
		Main.gui.onClickHand(pr);
	}
	static onClickPromote(b) {
		Main.gui.onClickPromote(b == 1);
	}
}
$hx_exports["Main"] = Main;
Main.__name__ = true;
Math.__name__ = true;
class PSQTable {
}
PSQTable.__name__ = true;
class Position {
	constructor() {
		if(Position._hx_skip_constructor) {
			return;
		}
		this._hx_constructor();
	}
	_hx_constructor() {
		this.nodes = 0;
		this.evalList = new EvalList();
		this.long_effect = new WordBoard();
		this.board_effect = new Array(2);
		this.materialValue = 0;
		this.pieceList = [];
		this.pieceCount = [];
		this.index = [];
		this.byColorBB = [];
		this.byTypeBB = [];
		this.hand = [];
		this.sideToMove = 0;
		this.board = [];
		LongEffect.init(this);
		this.InitBB();
		Zobrist.Init();
	}
	eval_list() {
		return this.evalList;
	}
	GetKey() {
		return this.st.key();
	}
	ADD_BOARD_EFFECT(c,to,e1) {
		this.board_effect[c].e[to] += e1;
	}
	InitBB() {
		this.byTypeBB = [];
		let _g = 0;
		let _g1 = 31;
		while(_g < _g1) {
			let i = _g++;
			this.byTypeBB.push(new Bitboard());
		}
		this.byColorBB = [];
		this.byColorBB.push(new Bitboard());
		this.pieceCount[0] = [];
		this.pieceList[0] = [];
		this.pieceCount[0][0] = 0;
		this.pieceList[0][0] = [];
		this.pieceCount[0][1] = 0;
		this.pieceList[0][1] = [];
		this.pieceCount[0][2] = 0;
		this.pieceList[0][2] = [];
		this.pieceCount[0][3] = 0;
		this.pieceList[0][3] = [];
		this.pieceCount[0][4] = 0;
		this.pieceList[0][4] = [];
		this.pieceCount[0][5] = 0;
		this.pieceList[0][5] = [];
		this.pieceCount[0][6] = 0;
		this.pieceList[0][6] = [];
		this.pieceCount[0][7] = 0;
		this.pieceList[0][7] = [];
		this.pieceCount[0][8] = 0;
		this.pieceList[0][8] = [];
		this.pieceCount[0][9] = 0;
		this.pieceList[0][9] = [];
		this.pieceCount[0][10] = 0;
		this.pieceList[0][10] = [];
		this.pieceCount[0][11] = 0;
		this.pieceList[0][11] = [];
		this.pieceCount[0][12] = 0;
		this.pieceList[0][12] = [];
		this.pieceCount[0][13] = 0;
		this.pieceList[0][13] = [];
		this.pieceCount[0][14] = 0;
		this.pieceList[0][14] = [];
		this.byColorBB.push(new Bitboard());
		this.pieceCount[1] = [];
		this.pieceList[1] = [];
		this.pieceCount[1][0] = 0;
		this.pieceList[1][0] = [];
		this.pieceCount[1][1] = 0;
		this.pieceList[1][1] = [];
		this.pieceCount[1][2] = 0;
		this.pieceList[1][2] = [];
		this.pieceCount[1][3] = 0;
		this.pieceList[1][3] = [];
		this.pieceCount[1][4] = 0;
		this.pieceList[1][4] = [];
		this.pieceCount[1][5] = 0;
		this.pieceList[1][5] = [];
		this.pieceCount[1][6] = 0;
		this.pieceList[1][6] = [];
		this.pieceCount[1][7] = 0;
		this.pieceList[1][7] = [];
		this.pieceCount[1][8] = 0;
		this.pieceList[1][8] = [];
		this.pieceCount[1][9] = 0;
		this.pieceList[1][9] = [];
		this.pieceCount[1][10] = 0;
		this.pieceList[1][10] = [];
		this.pieceCount[1][11] = 0;
		this.pieceList[1][11] = [];
		this.pieceCount[1][12] = 0;
		this.pieceList[1][12] = [];
		this.pieceCount[1][13] = 0;
		this.pieceList[1][13] = [];
		this.pieceCount[1][14] = 0;
		this.pieceList[1][14] = [];
		this.st = new StateInfo();
	}
	pawn_effect(sq,c) {
		return BB.stepAttacksBB[Types.Make_Piece(c,1)][sq];
	}
	AttackersToSq(sq) {
		return this.AttackersTo(sq,this.byTypeBB[0]);
	}
	Nodes() {
		return this.nodes;
	}
	Checkers() {
		return this.st.checkersBB;
	}
	in_check() {
		return this.Checkers().IsNonZero();
	}
	blockers_for_king(c) {
		return this.st.blockersForKing[c];
	}
	king_square(c) {
		return this.pieceList[c][8][0];
	}
	legal(m) {
		if(Types.is_drop(m)) {
			return true;
		}
		let us = this.sideToMove;
		let from = Types.move_from(m);
		if(Types.TypeOf_Piece(this.piece_on(from)) == 8) {
			if(!this.AttackersToSq(Types.move_to(m)).newAND(this.PiecesColour(Types.OppColour(us))).IsZero()) {
				return false;
			}
		}
		if(this.blockers_for_king(us).isSet(from)) {
			return Types.aligned(from,Types.to_sq(m),this.king_square(us));
		} else {
			return true;
		}
	}
	pieces() {
		return this.PiecesAll();
	}
	PiecesAll() {
		return this.byTypeBB[0];
	}
	PiecesColour(c) {
		return this.byColorBB[c];
	}
	PiecesColourType(c,pt) {
		return this.byColorBB[c].newAND(this.byTypeBB[pt]);
	}
	piece_on(sq) {
		let this1 = this.board[sq];
		return this1;
	}
	piecesType(pt) {
		return this.byTypeBB[pt];
	}
	between_bb(from,to) {
		return BB.betweenBB[from][to];
	}
	bona_piece_of(c,pt) {
		let ct = this.hand[c][pt];
		return this.evalList.kpp_hand_index[c][pt].fb + ct - 1;
	}
	piece_no_of_hand(c,pt) {
		return this.evalList.piece_no_of_hand(this.bona_piece_of(c,pt));
	}
	piece_no_of_sq(sq) {
		return this.evalList.piece_no_of_board(sq);
	}
	PiecesTypes(pt1,pt2) {
		return this.byTypeBB[pt1].newOR(this.byTypeBB[pt2]);
	}
	changeSideToMove() {
		this.sideToMove = Types.OppColour(this.sideToMove);
	}
	set_check_info(si) {
		si.blockersForKing[1] = this.slider_blockers(0,this.king_square(1),si.pinners[1]);
		si.blockersForKing[0] = this.slider_blockers(1,this.king_square(0),si.pinners[0]);
	}
	slider_blockers(c,s,pinners) {
		let us = Types.OppColour(c);
		let blockers = new Bitboard();
		let rook_dragons = this.piecesType(6).newOR(this.piecesType(14)).newAND(BB.rookStepEffect(s));
		let bishop_horses = this.piecesType(5).newOR(this.piecesType(13)).newAND(BB.bishopStepEffect(s));
		let lances = this.piecesType(2).newAND(BB.lanceStepEffect(us,s));
		let snipers = rook_dragons.newOR(bishop_horses).newOR(lances).newAND(this.PiecesColour(c));
		while(snipers.IsNonZero()) {
			let sniperSq = snipers.PopLSB();
			let b = this.between_bb(s,sniperSq).newAND(this.PiecesAll());
			if(b.IsNonZero() && !b.more_than_one()) {
				blockers.OR(b);
				if(b.newAND(this.PiecesColour(us)).IsNonZero()) {
					pinners.SetBit(b.LSB());
				}
			}
		}
		return blockers;
	}
	countNode() {
		this.nodes++;
	}
	resetNode() {
		this.nodes = 0;
	}
	do_move(move,newSt) {
		this.doMoveFull(move,newSt);
	}
	doMoveFull(move,newSt) {
		let from = Types.move_from(move);
		let to = Types.move_to(move);
		let us = this.sideToMove;
		let them = Types.OppColour(us);
		let pc = this.MovedPieceAfter(move);
		let pr = Types.RawTypeOf(pc);
		let pt = Types.TypeOf_Piece(pc);
		let moved_after_pc;
		if(Types.Move_Type(move) == 32768) {
			let this1 = pc + 8;
			moved_after_pc = this1;
		} else {
			moved_after_pc = pc;
		}
		let materialDiff = 0;
		this.countNode();
		newSt.Copy(this.st);
		newSt.previous = this.st;
		this.st = newSt;
		let k = this.st.board_key_.newXOR(Zobrist.side);
		let h = this.st.hand_key_;
		let dp = this.st.dirtyPiece;
		this.st.lastMove = move;
		if(Types.is_drop(move)) {
			pc = Types.Make_Piece(us,pt);
			h.MINUS(Zobrist.hand[us][pr]);
			k.PLUS(Zobrist.psq[to][pc]);
			let key = k.newPLUS(h);
			let this1 = pr;
			let piece_no = this.piece_no_of_hand(us,this1);
			dp.dirty_num = 1;
			dp.pieceNo[0] = piece_no;
			this.PutPiece(to,us,pt);
			this.evalList.put_piece(piece_no,to,pc);
			this.SubHand(us,pr);
			materialDiff = 0;
			LongEffect.update_by_dropping_piece(this,to,pc);
		} else {
			let capturedPC = this.piece_on(to);
			let captured = Types.TypeOf_Piece(capturedPC);
			let capturedRaw = Types.RawTypeOf(captured);
			if(captured != 0) {
				LongEffect.update_by_capturing_piece(this,from,to,pc,moved_after_pc,capturedPC);
				let capsq = to;
				let piece_no = this.piece_no_of_sq(to);
				dp.dirty_num = 2;
				dp.pieceNo[1] = piece_no;
				let this1 = capturedRaw;
				this.evalList.put_piece_hand(piece_no,us,this1,this.hand_count(us,capturedRaw));
				this.AddHand(us,capturedRaw);
				this.RemovePiece(capsq,them,captured);
				k.MINUS(Zobrist.psq[to][capturedPC]);
				h.PLUS(Zobrist.hand[us][capturedRaw]);
			} else {
				dp.dirty_num = 1;
				LongEffect.update_by_no_capturing_piece(this,from,to,pc,moved_after_pc);
			}
			let piece_no2 = this.piece_no_of_sq(from);
			dp.pieceNo[0] = piece_no2;
			this.RemovePiece(from,us,pt);
			this.MovePiece(from,to,us,pt);
			k.MINUS(Zobrist.psq[from][pc]);
			k.PLUS(Zobrist.psq[to][pc]);
			this.evalList.put_piece(piece_no2,to,pc);
			if(Types.Move_Type(move) == 32768) {
				this.RemovePiece(to,us,pt);
				let this1 = pt + 8;
				this.PutPiece(to,us,this1);
				k.MINUS(Zobrist.psq[to][pc]);
				k.PLUS(Zobrist.psq[to][pc + 8]);
				materialDiff = Evaluate.proDiffPieceValue[pt];
			}
			this.st.capturedType = captured;
			materialDiff += Evaluate.capturePieceValue[captured];
			this.st.materialValue = this.st.previous.materialValue + (us == 0 ? materialDiff : -materialDiff);
		}
		let tmp = this.AttackersToSq(this.king_square(them));
		let tmp1 = this.PiecesColour(us);
		this.st.checkersBB = tmp.newAND(tmp1);
		this.changeSideToMove();
		this.st.board_key_ = k;
		this.st.hand_key_ = h;
		this.set_check_info(this.st);
	}
	undo_move(move) {
		this.changeSideToMove();
		let us = this.sideToMove;
		let them = Types.OppColour(us);
		let to = Types.move_to(move);
		let pc = this.piece_on(to);
		let pr = Types.RawTypeOf(pc);
		let pt = Types.TypeOf_Piece(pc);
		let moved_after_pc = pc;
		let moved_pc;
		if(Types.Move_Type(move) == 32768) {
			let this1 = pc - 8;
			moved_pc = this1;
		} else {
			moved_pc = pc;
		}
		let piece_no = this.piece_no_of_sq(to);
		if(Types.is_drop(move)) {
			this.evalList.put_piece_hand(piece_no,us,pt,this.hand_count(us,pr));
			this.AddHand(us,pr);
			this.RemovePiece(to,us,pt);
			LongEffect.rewind_by_dropping_piece(this,to,moved_after_pc);
		} else {
			let from = Types.move_from(move);
			let captured = this.st.capturedType;
			let to_pc = Types.Make_Piece(them,captured);
			let capturedRaw = Types.RawTypeOf(captured);
			if(Types.Move_Type(move) == 32768) {
				let promotion = pt;
				let this1 = pt - 8;
				pt = this1;
				this.RemovePiece(to,us,promotion);
				this.PutPiece(from,us,pt);
			} else {
				this.RemovePiece(to,us,pt);
				this.PutPiece(from,us,pt);
			}
			if(captured != 0) {
				let capsq = to;
				let this1 = capturedRaw;
				let piece_no2 = this.piece_no_of_hand(us,this1);
				this.evalList.put_piece(piece_no2,to,to_pc);
				this.SubHand(us,capturedRaw);
				this.PutPiece(capsq,them,captured);
				this.evalList.put_piece(piece_no,from,moved_pc);
				LongEffect.rewind_by_capturing_piece(this,from,to,pc,moved_after_pc,to_pc);
			} else {
				this.evalList.put_piece(piece_no,from,moved_pc);
				LongEffect.rewind_by_no_capturing_piece(this,from,to,pc,moved_after_pc);
			}
		}
		this.st = this.st.previous;
	}
	PutPiece(sq,c,pt) {
		this.board[sq] = Types.Make_Piece(c,pt);
		this.byColorBB[c].SetBit(sq);
		this.byTypeBB[0].SetBit(sq);
		this.byTypeBB[pt].SetBit(sq);
		let tmp = this.pieceCount[c];
		tmp[0]++;
		let tmp1 = this.pieceCount[c];
		this.index[sq] = tmp1[pt]++;
		this.pieceList[c][pt][this.index[sq]] = sq;
		if(pt == 1) {
			BB.pawnLineBB[c].OR(BB.filesBB[Types.file_of(sq)]);
		}
	}
	MovePiece(from,to,c,pt) {
		this.board[to] = Types.Make_Piece(c,pt);
		this.board[from] = 0;
		this.byColorBB[c].SetBit(to);
		this.byTypeBB[0].SetBit(to);
		this.byTypeBB[pt].SetBit(to);
		this.index[to] = this.index[from];
		this.pieceList[c][pt][this.index[to]] = to;
		if(pt == 1) {
			BB.pawnLineBB[c].OR(BB.filesBB[Types.file_of(to)]);
		}
	}
	RemovePiece(sq,c,pt) {
		this.board[sq] = 0;
		this.byColorBB[c].ClrBit(sq);
		this.byTypeBB[0].ClrBit(sq);
		this.byTypeBB[pt].ClrBit(sq);
		let tmp = this.pieceCount[c];
		tmp[0]--;
		if(this.pieceCount[c][pt] > 0) {
			let tmp = this.pieceCount[c];
			tmp[pt]--;
		}
		let lastSquare = this.pieceList[c][pt][this.pieceCount[c][pt]];
		this.index[lastSquare] = this.index[sq];
		this.pieceList[c][pt][this.index[lastSquare]] = lastSquare;
		this.pieceList[c][pt][this.pieceCount[c][pt]] = 81;
		if(pt == 1) {
			BB.pawnLineBB[c].AND(BB.filesBB[Types.file_of(sq)].newNOT());
		}
	}
	HandExists(c,pr) {
		return this.hand[c][pr] > 0;
	}
	AddHand(c,pr,n) {
		if(n == null) {
			n = 1;
		}
		this.hand[c][pr] += n;
	}
	SubHand(c,pr,n) {
		if(n == null) {
			n = 1;
		}
		this.hand[c][pr] -= n;
	}
	hand_count(c,pr) {
		return this.hand[c][pr];
	}
	AttackersTo(s,occ) {
		let attBB = this.pawn_effect(s,0).newAND(this.PiecesColourType(1,1));
		attBB.OR(this.pawn_effect(s,1).newAND(this.PiecesColourType(0,1)));
		attBB.OR(this.AttacksFromPTypeSQ(s,19).newAND(this.PiecesColourType(0,3)));
		attBB.OR(this.AttacksFromPTypeSQ(s,3).newAND(this.PiecesColourType(1,3)));
		attBB.OR(this.AttacksFromPTypeSQ(s,18).newAND(this.PiecesColourType(0,2)));
		attBB.OR(this.AttacksFromPTypeSQ(s,2).newAND(this.PiecesColourType(1,2)));
		attBB.OR(this.AttacksFromPTypeSQ(s,20).newAND(this.PiecesColourType(0,4)));
		attBB.OR(this.AttacksFromPTypeSQ(s,4).newAND(this.PiecesColourType(1,4)));
		attBB.OR(this.AttacksFromPTypeSQ(s,23).newAND(this.PiecesColourType(0,7)));
		attBB.OR(this.AttacksFromPTypeSQ(s,7).newAND(this.PiecesColourType(1,7)));
		attBB.OR(this.AttacksFromPTypeSQ(s,25).newAND(this.PiecesColourType(0,9)));
		attBB.OR(this.AttacksFromPTypeSQ(s,9).newAND(this.PiecesColourType(1,9)));
		attBB.OR(this.AttacksFromPTypeSQ(s,26).newAND(this.PiecesColourType(0,10)));
		attBB.OR(this.AttacksFromPTypeSQ(s,10).newAND(this.PiecesColourType(1,10)));
		attBB.OR(this.AttacksFromPTypeSQ(s,27).newAND(this.PiecesColourType(0,11)));
		attBB.OR(this.AttacksFromPTypeSQ(s,11).newAND(this.PiecesColourType(1,11)));
		attBB.OR(this.AttacksFromPTypeSQ(s,28).newAND(this.PiecesColourType(0,12)));
		attBB.OR(this.AttacksFromPTypeSQ(s,12).newAND(this.PiecesColourType(1,12)));
		attBB.OR(BB.AttacksBB(s,occ,6).newAND(this.PiecesTypes(6,14)));
		attBB.OR(BB.AttacksBB(s,occ,5).newAND(this.PiecesTypes(5,13)));
		attBB.OR(this.AttacksFromPTypeSQ(s,8).newAND(this.PiecesTypes(14,13)));
		attBB.OR(this.AttacksFromPTypeSQ(s,8).newAND(this.piecesType(8)));
		return attBB;
	}
	MovedPieceAfter(m) {
		if(Types.is_drop(m)) {
			let this1 = m >>> 7 & 127;
			return this1;
		} else {
			return this.piece_on(Types.move_from(m));
		}
	}
	setPosition(sfen) {
		let piece_no_count = [0,0,18,22,26,34,36,30];
		this.InitBB();
		this.Clear();
		let sf = new SFEN(sfen);
		this.sideToMove = sf.SideToMove();
		this.board = sf.getBoard();
		let _g = 0;
		while(_g < 81) {
			let sq = _g++;
			let pc = this.piece_on(sq);
			let pt = Types.TypeOf_Piece(pc);
			let c = Types.getPieceColor(pc);
			if(pc == 0) {
				continue;
			}
			this.PutPiece(sq,c,pt);
			let piece_no;
			if(pc == 8) {
				piece_no = 38;
			} else if(pc == 24) {
				piece_no = 39;
			} else {
				let piece_no1 = Types.raw_type_of(pc);
				piece_no = piece_no_count[piece_no1]++;
			}
			this.evalList.put_piece(piece_no,sq,pc);
		}
		this.hand = sf.getHand();
		let _g1 = 0;
		let _g2 = this.hand[0][0];
		while(_g1 < _g2) {
			let i = _g1++;
			let piece_no = piece_no_count[0]++;
			let this1 = 0;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g3 = 0;
		let _g4 = this.hand[0][1];
		while(_g3 < _g4) {
			let i = _g3++;
			let piece_no = piece_no_count[1]++;
			let this1 = 1;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g5 = 0;
		let _g6 = this.hand[0][2];
		while(_g5 < _g6) {
			let i = _g5++;
			let piece_no = piece_no_count[2]++;
			let this1 = 2;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g7 = 0;
		let _g8 = this.hand[0][3];
		while(_g7 < _g8) {
			let i = _g7++;
			let piece_no = piece_no_count[3]++;
			let this1 = 3;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g9 = 0;
		let _g10 = this.hand[0][4];
		while(_g9 < _g10) {
			let i = _g9++;
			let piece_no = piece_no_count[4]++;
			let this1 = 4;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g11 = 0;
		let _g12 = this.hand[0][5];
		while(_g11 < _g12) {
			let i = _g11++;
			let piece_no = piece_no_count[5]++;
			let this1 = 5;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g13 = 0;
		let _g14 = this.hand[0][6];
		while(_g13 < _g14) {
			let i = _g13++;
			let piece_no = piece_no_count[6]++;
			let this1 = 6;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g15 = 0;
		let _g16 = this.hand[0][7];
		while(_g15 < _g16) {
			let i = _g15++;
			let piece_no = piece_no_count[7]++;
			let this1 = 7;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g17 = 0;
		let _g18 = this.hand[1][0];
		while(_g17 < _g18) {
			let i = _g17++;
			let piece_no = piece_no_count[0]++;
			let this1 = 0;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g19 = 0;
		let _g20 = this.hand[1][1];
		while(_g19 < _g20) {
			let i = _g19++;
			let piece_no = piece_no_count[1]++;
			let this1 = 1;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g21 = 0;
		let _g22 = this.hand[1][2];
		while(_g21 < _g22) {
			let i = _g21++;
			let piece_no = piece_no_count[2]++;
			let this1 = 2;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g23 = 0;
		let _g24 = this.hand[1][3];
		while(_g23 < _g24) {
			let i = _g23++;
			let piece_no = piece_no_count[3]++;
			let this1 = 3;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g25 = 0;
		let _g26 = this.hand[1][4];
		while(_g25 < _g26) {
			let i = _g25++;
			let piece_no = piece_no_count[4]++;
			let this1 = 4;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g27 = 0;
		let _g28 = this.hand[1][5];
		while(_g27 < _g28) {
			let i = _g27++;
			let piece_no = piece_no_count[5]++;
			let this1 = 5;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g29 = 0;
		let _g30 = this.hand[1][6];
		while(_g29 < _g30) {
			let i = _g29++;
			let piece_no = piece_no_count[6]++;
			let this1 = 6;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g31 = 0;
		let _g32 = this.hand[1][7];
		while(_g31 < _g32) {
			let i = _g31++;
			let piece_no = piece_no_count[7]++;
			let this1 = 7;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let moves = sf.getMoves();
		let _g33 = 0;
		let _g34 = moves.length;
		while(_g33 < _g34) {
			let i = _g33++;
			this.do_move(moves[i],new StateInfo());
		}
		this.set_state(this.st);
		LongEffect.calc_effect(this);
	}
	set_state(si) {
		let tmp = this.AttackersToSq(this.king_square(this.sideToMove));
		let tmp1 = this.PiecesColour(Types.OppColour(this.sideToMove));
		this.st.checkersBB = tmp.newAND(tmp1);
		this.set_check_info(si);
		si.board_key_ = this.sideToMove == 0 ? Zobrist.zero : Zobrist.side;
		si.hand_key_ = Zobrist.zero;
		let b = this.pieces().newCOPY();
		while(b.IsNonZero()) {
			let sq = b.PopLSB();
			let pc = this.piece_on(sq);
			si.board_key_.PLUS(Zobrist.psq[sq][pc]);
		}
		let _g = 1;
		let _g1 = 8;
		while(_g < _g1) {
			let pr = _g++;
			let this1 = pr;
			si.hand_key_.PLUS(Zobrist.hand[0][pr].newMULTI(this.hand_count(0,this1)));
		}
		let _g2 = 1;
		let _g3 = 8;
		while(_g2 < _g3) {
			let pr = _g2++;
			let this1 = pr;
			si.hand_key_.PLUS(Zobrist.hand[1][pr].newMULTI(this.hand_count(1,this1)));
		}
	}
	side_to_move() {
		return this.sideToMove;
	}
	SideToMove() {
		return this.sideToMove;
	}
	state() {
		return this.st;
	}
	AttacksFromPTypeSQ(sq,pc) {
		let pt = Types.TypeOf_Piece(pc);
		if(pt == 5 || pt == 6 || pt == 13 || pt == 14) {
			return BB.AttacksBB(sq,this.PiecesAll(),pt);
		} else if(pt == 2) {
			let rb = BB.AttacksBB(sq,this.PiecesAll(),6);
			let b = BB.getStepAttacksBB(pc,sq).newAND(rb);
			return b;
		} else {
			return BB.getStepAttacksBB(pc,sq);
		}
	}
	Clear() {
		this.nodes = 0;
		let _g = 0;
		while(_g < 81) {
			let i = _g++;
			this.board[i] = 0;
			this.index[i] = 0;
		}
		this.byTypeBB[0].Clear();
		this.byTypeBB[1].Clear();
		this.byTypeBB[2].Clear();
		this.byTypeBB[3].Clear();
		this.byTypeBB[4].Clear();
		this.byTypeBB[5].Clear();
		this.byTypeBB[6].Clear();
		this.byTypeBB[7].Clear();
		this.byTypeBB[8].Clear();
		this.byTypeBB[9].Clear();
		this.byTypeBB[10].Clear();
		this.byTypeBB[11].Clear();
		this.byTypeBB[12].Clear();
		this.byTypeBB[13].Clear();
		this.byTypeBB[14].Clear();
		this.byColorBB[0].Clear();
		this.pieceCount[0] = [];
		let _g1 = 0;
		while(_g1 < 15) {
			let j = _g1++;
			this.pieceCount[0][j] = 0;
			this.pieceList[0][j][0] = 0;
			this.pieceList[0][j][1] = 0;
			this.pieceList[0][j][2] = 0;
			this.pieceList[0][j][3] = 0;
			this.pieceList[0][j][4] = 0;
			this.pieceList[0][j][5] = 0;
			this.pieceList[0][j][6] = 0;
			this.pieceList[0][j][7] = 0;
			this.pieceList[0][j][8] = 0;
			this.pieceList[0][j][9] = 0;
			this.pieceList[0][j][10] = 0;
			this.pieceList[0][j][11] = 0;
			this.pieceList[0][j][12] = 0;
			this.pieceList[0][j][13] = 0;
			this.pieceList[0][j][14] = 0;
			this.pieceList[0][j][15] = 0;
		}
		this.byColorBB[1].Clear();
		this.pieceCount[1] = [];
		let _g2 = 0;
		while(_g2 < 15) {
			let j = _g2++;
			this.pieceCount[1][j] = 0;
			this.pieceList[1][j][0] = 0;
			this.pieceList[1][j][1] = 0;
			this.pieceList[1][j][2] = 0;
			this.pieceList[1][j][3] = 0;
			this.pieceList[1][j][4] = 0;
			this.pieceList[1][j][5] = 0;
			this.pieceList[1][j][6] = 0;
			this.pieceList[1][j][7] = 0;
			this.pieceList[1][j][8] = 0;
			this.pieceList[1][j][9] = 0;
			this.pieceList[1][j][10] = 0;
			this.pieceList[1][j][11] = 0;
			this.pieceList[1][j][12] = 0;
			this.pieceList[1][j][13] = 0;
			this.pieceList[1][j][14] = 0;
			this.pieceList[1][j][15] = 0;
		}
		let _g3 = 0;
		while(_g3 < 15) {
			let i = _g3++;
			let _g = 0;
			while(_g < 16) {
				let j = _g++;
				this.pieceList[1][i][j] = 81;
				this.pieceList[0][i][j] = 81;
			}
		}
	}
	printBoard(msg) {
		if(msg == null) {
			msg = "";
		}
		let s = "+++ printBoard +++ : " + msg;
		s += "\n";
		let f = 8;
		while(f >= 0) {
			let sq = Types.Square(f,0);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f;
		}
		s += "\n";
		let f1 = 8;
		while(f1 >= 0) {
			let sq = Types.Square(f1,1);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f1;
		}
		s += "\n";
		let f2 = 8;
		while(f2 >= 0) {
			let sq = Types.Square(f2,2);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f2;
		}
		s += "\n";
		let f3 = 8;
		while(f3 >= 0) {
			let sq = Types.Square(f3,3);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f3;
		}
		s += "\n";
		let f4 = 8;
		while(f4 >= 0) {
			let sq = Types.Square(f4,4);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f4;
		}
		s += "\n";
		let f5 = 8;
		while(f5 >= 0) {
			let sq = Types.Square(f5,5);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f5;
		}
		s += "\n";
		let f6 = 8;
		while(f6 >= 0) {
			let sq = Types.Square(f6,6);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f6;
		}
		s += "\n";
		let f7 = 8;
		while(f7 >= 0) {
			let sq = Types.Square(f7,7);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f7;
		}
		s += "\n";
		let f8 = 8;
		while(f8 >= 0) {
			let sq = Types.Square(f8,8);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f8;
		}
		haxe_Log.trace(s,{ fileName : "Position.hx", lineNumber : 614, className : "Position", methodName : "printBoard"});
	}
	printHand() {
		haxe_Log.trace(this.hand,{ fileName : "Position.hx", lineNumber : 618, className : "Position", methodName : "printHand"});
	}
	printPieceNo() {
		this.evalList.printPieceNo();
	}
	static Init() {
		Position.psq[0] = [];
		Position.psq[1] = [];
		let _g = 0;
		let _g1 = 15;
		while(_g < _g1) {
			let pt = _g++;
			Position.psq[0][pt] = [];
			Position.psq[1][pt] = [];
			let v = Position.pieceValue[pt];
			let _g1 = 0;
			while(_g1 < 81) {
				let s = _g1++;
				let sFlip = Types.FlipSquare(s);
				Position.psq[0][pt][s] = v + PSQTable.psqT[pt][s];
				Position.psq[1][pt][sFlip] = -(v + PSQTable.psqT[pt][s]);
			}
		}
	}
}
Position.__name__ = true;
class SFEN {
	constructor(sfen) {
		this.moves = [];
		this.hand = [[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]];
		this.sideToMove = 0;
		this.board = [];
		this.setPosition(sfen);
	}
	getBoard() {
		let arr = [];
		let _g = 0;
		while(_g < 81) {
			let i = _g++;
			arr.push(this.board[i]);
		}
		return arr;
	}
	getHand() {
		return this.hand;
	}
	getMoves() {
		return this.moves;
	}
	SideToMove() {
		return this.sideToMove;
	}
	setPosition(sfen) {
		sfen = StringTools.replace(sfen,"startpos","lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1");
		sfen = StringTools.replace(sfen,"sfen ","");
		haxe_Log.trace("SFEN::setPosition",{ fileName : "SFEN.hx", lineNumber : 45, className : "SFEN", methodName : "setPosition", customParams : [sfen]});
		let tokens = sfen.split(" ");
		let f = 8;
		let r = 0;
		let promote = false;
		let i = 0;
		let token = "";
		let sq = 0;
		this.board = [];
		haxe_Log.trace(tokens,{ fileName : "SFEN.hx", lineNumber : 54, className : "SFEN", methodName : "setPosition"});
		let _g = 0;
		let _g1 = tokens[0].length;
		while(_g < _g1) {
			let i = _g++;
			let token = tokens[0].charAt(i);
			if(util_StringUtil.isNumberString(token)) {
				let _g = 0;
				let _g1 = Std.parseInt(token);
				while(_g < _g1) {
					let n = _g++;
					sq = f * 9 + r;
					this.board[sq] = 0;
					--f;
				}
			} else if(token == "+") {
				promote = true;
			} else if(token == "/") {
				f = 8;
				++r;
			} else {
				sq = f * 9 + r;
				let pc = Types.getPieceFromLabel(token);
				if(promote) {
					let this1 = pc + 8;
					pc = this1;
				}
				this.board[sq] = pc;
				--f;
				promote = false;
			}
		}
		this.sideToMove = tokens[1] == "b" ? 0 : 1;
		let ct = 0;
		let _g2 = 0;
		let _g3 = tokens[2].length;
		while(_g2 < _g3) {
			let i = _g2++;
			let token = tokens[2].charAt(i);
			if(token == "-") {
				break;
			} else if(util_StringUtil.isNumberString(token)) {
				ct = Std.parseInt(token) + ct * 10;
			} else {
				ct = util_MathUtil.max(ct,1);
				let pc = Types.getPieceFromLabel(token);
				this.hand[Types.getPieceColor(pc)][Types.RawTypeOf(pc)] = ct;
				ct = 0;
			}
		}
		if(sfen.indexOf("moves") > 0) {
			let mvs = sfen.split("moves ")[1].split(" ");
			let _g = 0;
			let _g1 = mvs.length;
			while(_g < _g1) {
				let i = _g++;
				let m = Types.generateMoveFromString(mvs[i]);
				this.moves.push(m);
			}
		}
	}
}
SFEN.__name__ = true;
class StateInfo {
	constructor() {
		this.hand_key_ = new Bitboard64();
		this.board_key_ = new Bitboard64();
		this.sum = new EvalSum();
		this.dirtyPiece = new DirtyPiece();
		this.materialValue = 0;
		this.capturedType = 0;
		this.pinners = new Array(2);
		this.blockersForKing = new Array(2);
		this.checkersBB = new Bitboard();
		this.blockersForKing[0] = new Bitboard();
		this.pinners[0] = new Bitboard();
		this.blockersForKing[1] = new Bitboard();
		this.pinners[1] = new Bitboard();
	}
	key() {
		return this.long_key();
	}
	long_key() {
		return this.board_key_.newPLUS(this.hand_key_);
	}
	printKey() {
		haxe_Log.trace("KEY:" + this.key().toStringBB(),{ fileName : "StateInfo.hx", lineNumber : 38, className : "StateInfo", methodName : "printKey"});
	}
	Clear() {
		this.checkersBB.Clear();
		let this1 = 0;
		this.capturedType = this1;
		this.materialValue = 0;
		this.dirtyPiece = new DirtyPiece();
		this.checkersBB = new Bitboard();
		this.blockersForKing[0] = new Bitboard();
		this.pinners[0] = new Bitboard();
		this.blockersForKing[1] = new Bitboard();
		this.pinners[1] = new Bitboard();
		this.previous = null;
		this.sum = new EvalSum();
	}
	Copy(other) {
		this.checkersBB.Copy(other.checkersBB);
		this.capturedType = other.capturedType;
		this.materialValue = other.materialValue;
		this.previous = other.previous;
		this.blockersForKing[0].Copy(other.blockersForKing[0]);
		this.pinners[0].Copy(other.pinners[0]);
		this.blockersForKing[1].Copy(other.blockersForKing[1]);
		this.pinners[1].Copy(other.pinners[1]);
		this.board_key_ = other.board_key_.newCOPY();
		this.hand_key_ = other.hand_key_.newCOPY();
		this.lastMove = other.lastMove;
	}
}
StateInfo.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		if(x != null) {
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				let c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					let nc = x.charCodeAt(i + 1);
					let v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
}
Std.__name__ = true;
class StringTools {
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = true;
class Move {
	static _new(i) {
		let this1 = i;
		return this1;
	}
}
class PR {
	static _new(i) {
		let this1 = i;
		return this1;
	}
}
class PT {
	static _new(i) {
		let this1 = i;
		return this1;
	}
}
class PC {
	static _new(i) {
		let this1 = i;
		return this1;
	}
}
class Types {
	static sqww_to_sq(sqww) {
		return sqww & 255;
	}
	static to_sqww(sq) {
		return Types.sqww_table[sq];
	}
	static to_directions(d) {
		return 1 << d;
	}
	static is_ok(sqww) {
		return (sqww & 277094400) == 0;
	}
	static DirectToDeltaWW(d) {
		return Types.DirectToDeltaWW_[d];
	}
	static directions_of(sq1,sq2) {
		return Types.direc_table[sq1][sq2];
	}
	static aligned(sq1,sq2,sq3) {
		return BB.ANDsq(BB.lineBB[sq1][sq2],sq3).IsNonZero();
	}
	static Inv(sq) {
		return 80 - sq;
	}
	static mated_in(ply) {
		return -30000 + ply;
	}
	static has_long_effect(pc) {
		if(Types.type_of(pc) != 2) {
			return (pc + 1 & 6) == 6;
		} else {
			return true;
		}
	}
	static OppColour(c) {
		return c ^ 1;
	}
	static Is_SqOK(s) {
		if(s >= 0) {
			return s <= 80;
		} else {
			return false;
		}
	}
	static file_of(s) {
		return Types.SquareToFile[s];
	}
	static rank_of(s) {
		return Types.SquareToRank[s];
	}
	static dist(sq1,sq2) {
		if(!Types.is_ok(sq1) || !Types.is_ok(sq2)) {
			return 2147483647;
		} else {
			return util_MathUtil.max(util_MathUtil.abs(Types.file_of(sq1) - Types.file_of(sq2)),util_MathUtil.abs(Types.rank_of(sq1) - Types.rank_of(sq2)));
		}
	}
	static FileString_Of(s) {
		return "" + (Types.file_of(s) + 1);
	}
	static File_To_Char(f) {
		return "" + (f + 1);
	}
	static Rank_To_Char(r,toLower) {
		if(toLower == null) {
			toLower = true;
		}
		if(toLower) {
			let code = HxOverrides.cca("a",0) + r;
			return String.fromCodePoint(code);
		} else {
			let code = HxOverrides.cca("A",0) + r;
			return String.fromCodePoint(code);
		}
	}
	static Square_To_String(s) {
		return Types.File_To_Char(Types.file_of(s)) + Types.Rank_To_Char(Types.rank_of(s));
	}
	static Char_To_File(n) {
		return Std.parseInt(n) - 1;
	}
	static Char_To_Rank(a) {
		return HxOverrides.cca(a,0) - 97;
	}
	static move_from(m) {
		return m >>> 7 & 127;
	}
	static to_sq(m) {
		return Types.move_to(m);
	}
	static move_to(m) {
		return m & 127;
	}
	static Move_Dropped_Piece(m) {
		let this1 = m >>> 7 & 127;
		return this1;
	}
	static Move_Type(m) {
		return m & 49152;
	}
	static Move_To_String(m) {
		if(Types.is_drop(m)) {
			let this1 = Types.Move_Dropped_Piece(m);
			let pc = Types.PieceToChar(this1);
			let str = Types.Square_To_String(Types.move_to(m));
			return "" + pc + "*" + str;
		} else if(Types.Is_Promote(m)) {
			return Types.Square_To_String(Types.move_from(m)) + Types.Square_To_String(Types.move_to(m)) + "+";
		} else {
			return Types.Square_To_String(Types.move_from(m)) + Types.Square_To_String(Types.move_to(m));
		}
	}
	static Move_To_StringLong(m) {
		return Types.Move_To_String(m) + " " + Types.Move_Type_String(m) + " : " + m;
	}
	static Move_Type_String(m) {
		if(Types.Move_Type(m) == 16384) {
			return "Drop";
		}
		if(Types.Move_Type(m) == 32768) {
			return "Promo";
		}
		return "Normal";
	}
	static Make_Move(from,to) {
		let this1 = to | from << 7;
		return this1;
	}
	static Make_Move_Promote(from,to) {
		let this1 = to | from << 7 | 32768;
		return this1;
	}
	static Make_Move_Drop(pr,sq) {
		let this1 = sq | pr << 7 | 16384;
		return this1;
	}
	static generateMoveFromString(ft) {
		let f = Types.Char_To_File(ft.charAt(0));
		let r = Types.Char_To_Rank(ft.charAt(1));
		let from = Types.Square(f,r);
		f = Types.Char_To_File(ft.charAt(2));
		r = Types.Char_To_Rank(ft.charAt(3));
		let to = Types.Square(f,r);
		if(ft.indexOf("*") > 0) {
			let pr = Types.RawTypeOf(Types.getPieceFromLabel(ft.charAt(0)));
			f = Types.Char_To_File(ft.charAt(2));
			r = Types.Char_To_Rank(ft.charAt(3));
			to = Types.Square(f,r);
			return Types.Make_Move_Drop(pr,to);
		} else if(ft.indexOf("+") > 0) {
			return Types.Make_Move_Promote(from,to);
		} else {
			return Types.Make_Move(from,to);
		}
	}
	static Is_Move_OK(m) {
		return Types.move_from(m) != Types.move_to(m);
	}
	static Is_Promote(m) {
		return (m & 32768) != 0;
	}
	static is_drop(m) {
		return (m & 16384) != 0;
	}
	static RankString_Of(s) {
		let code = 97 + Types.rank_of(s);
		return String.fromCodePoint(code);
	}
	static type_of(pc) {
		let this1 = pc & 15;
		return this1;
	}
	static raw_type_of(p) {
		return Types.RawTypeOf(p);
	}
	static RawTypeOf(p) {
		let this1 = p % 8;
		return this1;
	}
	static Make_Piece(c,pt) {
		let this1 = c << 4 | pt;
		return this1;
	}
	static Square(f,r) {
		return f * 9 + r;
	}
	static FlipSquare(sq) {
		return Types.flipSquare[sq];
	}
	static color_of(pc) {
		return (pc & 16) >> 4;
	}
	static getPieceColor(pc) {
		if(pc == 0) {
			return -1;
		}
		if((pc | 0) < 16) {
			return 0;
		} else {
			return 1;
		}
	}
	static TypeOf_Piece(pc) {
		let this1 = pc % 16;
		return this1;
	}
	static PieceToChar(pc) {
		if(pc == 1) {
			return "P";
		}
		if(pc == 2) {
			return "L";
		}
		if(pc == 4) {
			return "S";
		}
		if(pc == 3) {
			return "N";
		}
		if(pc == 5) {
			return "B";
		}
		if(pc == 6) {
			return "R";
		}
		if(pc == 7) {
			return "G";
		}
		if(pc == 8) {
			return "K";
		}
		if(pc == 9) {
			return "+P";
		}
		if(pc == 10) {
			return "+L";
		}
		if(pc == 11) {
			return "+N";
		}
		if(pc == 12) {
			return "+S";
		}
		if(pc == 13) {
			return "+B";
		}
		if(pc == 14) {
			return "+R";
		}
		if(pc == 17) {
			return "p";
		}
		if(pc == 18) {
			return "l";
		}
		if(pc == 19) {
			return "n";
		}
		if(pc == 20) {
			return "s";
		}
		if(pc == 21) {
			return "b";
		}
		if(pc == 22) {
			return "r";
		}
		if(pc == 23) {
			return "g";
		}
		if(pc == 24) {
			return "k";
		}
		if(pc == 25) {
			return "+p";
		}
		if(pc == 26) {
			return "+l";
		}
		if(pc == 27) {
			return "+n";
		}
		if(pc == 28) {
			return "+s";
		}
		if(pc == 29) {
			return "+b";
		}
		if(pc == 30) {
			return "+r";
		}
		return "?";
	}
	static getPieceFromLabel(token) {
		switch(token) {
		case "B":
			return 5;
		case "G":
			return 7;
		case "K":
			return 8;
		case "L":
			return 2;
		case "N":
			return 3;
		case "P":
			return 1;
		case "R":
			return 6;
		case "S":
			return 4;
		case "b":
			return 21;
		case "g":
			return 23;
		case "k":
			return 24;
		case "l":
			return 18;
		case "n":
			return 19;
		case "p":
			return 17;
		case "r":
			return 22;
		case "s":
			return 20;
		default:
			return 0;
		}
	}
	static getPieceLabel(pt) {
		switch((pt | 0) % 16) {
		case 0:
			return "　";
		case 1:
			return "歩";
		case 2:
			return "香";
		case 3:
			return "桂";
		case 4:
			return "銀";
		case 5:
			return "角";
		case 6:
			return "飛";
		case 7:
			return "金";
		case 8:
			return "玉";
		case 9:
			return "と";
		case 10:
			return "杏";
		case 11:
			return "圭";
		case 12:
			return "全";
		case 13:
			return "馬";
		case 14:
			return "龍";
		default:
			return "　";
		}
	}
}
Types.__name__ = true;
class Zobrist {
	constructor() {
	}
	static Init() {
		haxe_Log.trace("Zobrist::Init",{ fileName : "Zobrist.hx", lineNumber : 14, className : "Zobrist", methodName : "Init"});
		let rk = new util_RKiss();
		let _g = 0;
		while(_g < 81) {
			let sq = _g++;
			let this1 = Zobrist.psq;
			let this2 = new Array(31);
			this1[sq] = this2;
			Zobrist.psq[sq][0] = new Bitboard64(0,0);
			let _g1 = 1;
			let _g2 = 31;
			while(_g1 < _g2) {
				let pc = _g1++;
				Zobrist.psq[sq][pc] = rk.Rand64();
			}
		}
		let this1 = Zobrist.hand;
		let this2 = new Array(8);
		this1[0] = this2;
		Zobrist.hand[0][0] = new Bitboard64(0,0);
		Zobrist.hand[0][1] = rk.Rand64();
		Zobrist.hand[0][2] = rk.Rand64();
		Zobrist.hand[0][3] = rk.Rand64();
		Zobrist.hand[0][4] = rk.Rand64();
		Zobrist.hand[0][5] = rk.Rand64();
		Zobrist.hand[0][6] = rk.Rand64();
		Zobrist.hand[0][7] = rk.Rand64();
		let this3 = Zobrist.hand;
		let this4 = new Array(8);
		this3[1] = this4;
		Zobrist.hand[1][0] = new Bitboard64(0,0);
		Zobrist.hand[1][1] = rk.Rand64();
		Zobrist.hand[1][2] = rk.Rand64();
		Zobrist.hand[1][3] = rk.Rand64();
		Zobrist.hand[1][4] = rk.Rand64();
		Zobrist.hand[1][5] = rk.Rand64();
		Zobrist.hand[1][6] = rk.Rand64();
		Zobrist.hand[1][7] = rk.Rand64();
		Zobrist.depth[0] = rk.Rand64();
		Zobrist.depth[1] = rk.Rand64();
		Zobrist.depth[2] = rk.Rand64();
		Zobrist.depth[3] = rk.Rand64();
		Zobrist.depth[4] = rk.Rand64();
		Zobrist.depth[5] = rk.Rand64();
	}
}
Zobrist.__name__ = true;
class haxe_Log {
	static formatOutput(v,infos) {
		let str = Std.string(v);
		if(infos == null) {
			return str;
		}
		let pstr = infos.fileName + ":" + infos.lineNumber;
		if(infos.customParams != null) {
			let _g = 0;
			let _g1 = infos.customParams;
			while(_g < _g1.length) {
				let v = _g1[_g];
				++_g;
				str += ", " + Std.string(v);
			}
		}
		return pstr + ": " + str;
	}
	static trace(v,infos) {
		let str = haxe_Log.formatOutput(v,infos);
		if(typeof(console) != "undefined" && console.log != null) {
			console.log(str);
		}
	}
}
haxe_Log.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
class ui_Game extends Position {
	constructor(ui_) {
		Position._hx_skip_constructor = true;
		super();
		Position._hx_skip_constructor = false;
		this._hx_constructor(ui_);
	}
	_hx_constructor(ui_) {
		this.moves = [];
		this._sfen = "startpos";
		this.playerColor = 0;
		haxe_Log.trace("Game::new",{ fileName : "ui/Game.hx", lineNumber : 23, className : "ui.Game", methodName : "new"});
		super._hx_constructor();
		this.ui = ui_;
		this.createWorker();
		BB.Init();
	}
	getLastMove() {
		if(this.moves.length == 0) {
			return null;
		} else {
			return this.moves[this.moves.length - 1];
		}
	}
	createWorker() {
		haxe_Log.trace("Game::createWorker",{ fileName : "ui/Game.hx", lineNumber : 38, className : "ui.Game", methodName : "createWorker"});
		this.worker = new Worker("Engine.js");
		this.worker.onmessage = $bind(this,this.onMessage);
	}
	doPlayerMove(from,to,promote) {
		if(promote) {
			this.do_move(Types.Make_Move_Promote(from,to),new StateInfo());
		} else {
			this.do_move(Types.Make_Move(from,to),new StateInfo());
		}
	}
	doPlayerPut(pr,to) {
		haxe_Log.trace("Game::doPlayerPut pr: " + pr + " to: " + to,{ fileName : "ui/Game.hx", lineNumber : 52, className : "ui.Game", methodName : "doPlayerPut"});
		let move = Types.Make_Move_Drop(pr,to);
		this.do_move(move,new StateInfo());
	}
	do_move(move,newSt) {
		haxe_Log.trace("Game::do_move " + Types.Move_To_String(move),{ fileName : "ui/Game.hx", lineNumber : 58, className : "ui.Game", methodName : "do_move"});
		this.moves.push(move);
		super.do_move(move,newSt);
		if(this.isEnemyTurn()) {
			this.startThink();
		}
	}
	startThink() {
		if(this.moves.length == 0) {
			this.worker.postMessage("position " + this._sfen);
		} else {
			this.worker.postMessage("position " + this._sfen + " moves " + this.getMovesString());
		}
	}
	getMovesString() {
		let s = Types.Move_To_String(this.moves[0]);
		let _g = 1;
		let _g1 = this.moves.length;
		while(_g < _g1) {
			let i = _g++;
			s += " " + Types.Move_To_String(this.moves[i]);
		}
		return s;
	}
	getMovableSq(sq,pc) {
		let arr = [];
		let us = this.sideToMove;
		let attack = this.AttacksFromPTypeSQ(sq,pc);
		let target = this.byColorBB[us].newNOT();
		let b = attack.newAND(target);
		while(b.IsNonZero()) arr.push(b.PopLSB());
		return arr;
	}
	getEmptySq(pr) {
		let us = this.sideToMove;
		let b = this.PiecesAll().newNOT().NORM27();
		let this1 = pr;
		if(this1 == 1) {
			b.AND(BB.pawnLineBB[us].newNOT());
		}
		haxe_Log.trace(b.toStringBB(),{ fileName : "ui/Game.hx", lineNumber : 103, className : "ui.Game", methodName : "getEmptySq"});
		let arr = [];
		while(b.IsNonZero()) arr.push(b.PopLSB());
		return arr;
	}
	isEnemyTurn() {
		return this.sideToMove != this.playerColor;
	}
	onMessage(s) {
		haxe_Log.trace("Game::onThink " + Std.string(s.data),{ fileName : "ui/Game.hx", lineNumber : 116, className : "ui.Game", methodName : "onMessage"});
		let tokens = s.data.split(" ");
		let move = Types.generateMoveFromString(tokens[1]);
		if(move == 0) {
			this.endGame();
		} else {
			this.do_move(move,new StateInfo());
			this.ui.onEnemyMoved();
		}
	}
	start() {
		haxe_Log.trace("Game::start",{ fileName : "ui/Game.hx", lineNumber : 128, className : "ui.Game", methodName : "start"});
		this.setPosition(this._sfen);
	}
	endGame() {
		haxe_Log.trace("Game::End",{ fileName : "ui/Game.hx", lineNumber : 133, className : "ui.Game", methodName : "endGame"});
		this.ui.onEndGame(this.sideToMove);
	}
	setPosition(sfen) {
		super.setPosition(sfen);
		if(this.isEnemyTurn()) {
			this.ui.updateUi(3);
			this.startThink();
		} else {
			this.ui.updateUi(0);
		}
	}
}
ui_Game.__name__ = true;
class ui_UI {
	constructor() {
		this.selectedHand = 0;
		this.toSq = 0;
		this.selectedSq = 0;
		this.operationMode = 0;
		window.onload = $bind(this,this.onLoad);
		this.game = new ui_Game(this);
	}
	onLoad() {
		this.Init();
		this.game.start();
	}
	Init() {
		this.hideDialog();
	}
	showDialog() {
		window.document.getElementById("dialog_promote").style.display = "block";
		window.document.getElementById("dialog_bg").style.display = "block";
	}
	hideDialog() {
		window.document.getElementById("dialog_promote").style.display = "none";
		window.document.getElementById("dialog_bg").style.display = "none";
	}
	onClickPromote(promote) {
		haxe_Log.trace("onClickPromote " + (promote == null ? "null" : "" + promote),{ fileName : "ui/UI.hx", lineNumber : 42, className : "ui.UI", methodName : "onClickPromote"});
		this.hideDialog();
		this.game.doPlayerMove(this.selectedSq,this.toSq,promote);
		this.updateUi(3);
	}
	isPromotable(sq,pc) {
		haxe_Log.trace("isPromotable sq:" + sq + " pc:" + pc,{ fileName : "ui/UI.hx", lineNumber : 49, className : "ui.UI", methodName : "isPromotable"});
		let pt = Types.TypeOf_Piece(pc);
		if((pt | 0) >= (7 | 0)) {
			return false;
		}
		if(Types.rank_of(sq) < 3) {
			return true;
		}
		if(Types.rank_of(this.selectedSq) < 3) {
			return true;
		} else {
			return false;
		}
	}
	onClickCell(sq) {
		haxe_Log.trace("on clickCell:",{ fileName : "ui/UI.hx", lineNumber : 66, className : "ui.UI", methodName : "onClickCell", customParams : [sq]});
		switch(this.operationMode) {
		case 0:
			this.selectedSq = sq;
			this.updateUi(1);
			break;
		case 1:
			this.toSq = sq;
			let from_pc = this.game.piece_on(this.selectedSq);
			if(this.isPromotable(this.toSq,from_pc)) {
				this.showDialog();
			} else {
				this.game.doPlayerMove(this.selectedSq,this.toSq,false);
				this.updateUi(3);
			}
			break;
		case 2:
			this.game.doPlayerPut(this.selectedHand,sq);
			this.updateUi(3);
			break;
		default:
		}
	}
	onClickHand(pr) {
		haxe_Log.trace("on clickHand:",{ fileName : "ui/UI.hx", lineNumber : 88, className : "ui.UI", methodName : "onClickHand", customParams : [pr]});
		if(this.operationMode == 0) {
			this.selectedHand = pr;
			this.updateUi(2);
		}
	}
	onEnemyMoved() {
		haxe_Log.trace("UI::onEnemyMoved",{ fileName : "ui/UI.hx", lineNumber : 98, className : "ui.UI", methodName : "onEnemyMoved"});
		this.updateUi(0);
	}
	onEndGame(winner) {
		window.alert(Std.string("" + winner + "の勝ちです"));
	}
	isPlayerPiece(sq,pc) {
		let c = Types.getPieceColor(pc);
		if(this.game.sideToMove == c) {
			return (pc | 0) > 0;
		} else {
			return false;
		}
	}
	updateUi(mode) {
		let linkable = false;
		let this1 = 0;
		let pc = this1;
		this.operationMode = mode;
		switch(this.operationMode) {
		case 0:
			let _g = 0;
			while(_g < 81) {
				let sq = _g++;
				pc = this.game.piece_on(sq);
				if(this.isPlayerPiece(sq,pc)) {
					let arr = this.game.getMovableSq(sq,pc);
					if(arr.length > 0) {
						linkable = true;
					} else {
						linkable = false;
					}
				} else {
					linkable = false;
				}
				this.setCell(sq,this.game.piece_on(sq),linkable);
			}
			let _g1 = 1;
			while(_g1 < 8) {
				let i = _g1++;
				this.setHand(0,i,this.game.hand[0][i],this.game.hand[0][i] > 0);
				this.setHand(1,i,this.game.hand[1][i],false);
			}
			break;
		case 1:
			pc = this.game.piece_on(this.selectedSq);
			let arr = this.game.getMovableSq(this.selectedSq,pc);
			let _g2 = 0;
			while(_g2 < 81) {
				let sq = _g2++;
				linkable = arr.indexOf(sq) > -1;
				this.setCell(sq,this.game.piece_on(sq),linkable);
			}
			this.setHand(0,1,this.game.hand[0][1],false);
			this.setHand(1,1,this.game.hand[1][1],false);
			this.setHand(0,2,this.game.hand[0][2],false);
			this.setHand(1,2,this.game.hand[1][2],false);
			this.setHand(0,3,this.game.hand[0][3],false);
			this.setHand(1,3,this.game.hand[1][3],false);
			this.setHand(0,4,this.game.hand[0][4],false);
			this.setHand(1,4,this.game.hand[1][4],false);
			this.setHand(0,5,this.game.hand[0][5],false);
			this.setHand(1,5,this.game.hand[1][5],false);
			this.setHand(0,6,this.game.hand[0][6],false);
			this.setHand(1,6,this.game.hand[1][6],false);
			this.setHand(0,7,this.game.hand[0][7],false);
			this.setHand(1,7,this.game.hand[1][7],false);
			break;
		case 2:
			let arr1 = this.game.getEmptySq(this.selectedHand);
			let _g3 = 0;
			while(_g3 < 81) {
				let sq = _g3++;
				linkable = arr1.indexOf(sq) > -1;
				this.setCell(sq,this.game.piece_on(sq),linkable);
			}
			this.setHand(0,1,this.game.hand[0][1],false);
			this.setHand(1,1,this.game.hand[1][1],false);
			this.setHand(0,2,this.game.hand[0][2],false);
			this.setHand(1,2,this.game.hand[1][2],false);
			this.setHand(0,3,this.game.hand[0][3],false);
			this.setHand(1,3,this.game.hand[1][3],false);
			this.setHand(0,4,this.game.hand[0][4],false);
			this.setHand(1,4,this.game.hand[1][4],false);
			this.setHand(0,5,this.game.hand[0][5],false);
			this.setHand(1,5,this.game.hand[1][5],false);
			this.setHand(0,6,this.game.hand[0][6],false);
			this.setHand(1,6,this.game.hand[1][6],false);
			this.setHand(0,7,this.game.hand[0][7],false);
			this.setHand(1,7,this.game.hand[1][7],false);
			break;
		default:
			let _g4 = 0;
			while(_g4 < 81) {
				let sq = _g4++;
				this.setCell(sq,this.game.piece_on(sq),false);
			}
			this.setHand(0,1,this.game.hand[0][1],false);
			this.setHand(1,1,this.game.hand[1][1],false);
			this.setHand(0,2,this.game.hand[0][2],false);
			this.setHand(1,2,this.game.hand[1][2],false);
			this.setHand(0,3,this.game.hand[0][3],false);
			this.setHand(1,3,this.game.hand[1][3],false);
			this.setHand(0,4,this.game.hand[0][4],false);
			this.setHand(1,4,this.game.hand[1][4],false);
			this.setHand(0,5,this.game.hand[0][5],false);
			this.setHand(1,5,this.game.hand[1][5],false);
			this.setHand(0,6,this.game.hand[0][6],false);
			this.setHand(1,6,this.game.hand[1][6],false);
			this.setHand(0,7,this.game.hand[0][7],false);
			this.setHand(1,7,this.game.hand[1][7],false);
		}
	}
	isLastMove(sq) {
		let isLastMove = false;
		let lastMove = this.game.getLastMove();
		if(lastMove == null) {
			return false;
		}
		let to = Types.to_sq(lastMove);
		return sq == to;
	}
	setCell(sq,pc,linkable) {
		let c = Types.getPieceColor(pc);
		let s = "" + Types.getPieceLabel(Types.TypeOf_Piece(pc));
		if(this.isLastMove(sq)) {
			s = "<b>" + s + "</b>";
		}
		if(linkable) {
			s = "<a href=\"javascript:Main.onClickCell(" + sq + ")\">" + s + "</a>";
		}
		let cell = window.document.getElementById("cell_" + sq);
		if(this.game.playerColor == c) {
			cell.style.transform = "";
		} else {
			cell.style.transform = "rotate(180deg)";
		}
		cell.innerHTML = s;
	}
	setHand(c,i,n,linkable) {
		let cell = window.document.getElementById("hand_" + c + "_" + i);
		let s = "　";
		if(n > 0) {
			let this1 = i;
			s = "" + Types.getPieceLabel(this1) + n;
		}
		if(linkable) {
			s = "<a href=\"javascript:Main.onClickHand(" + i + ")\">" + s + "</a>";
		}
		if(this.game.playerColor == c) {
			cell.style.transform = "";
		} else {
			cell.style.transform = "rotate(180deg)";
		}
		cell.innerHTML = s;
	}
}
ui_UI.__name__ = true;
class util_RKiss {
	constructor() {
		this.d = new Bitboard64();
		this.c = new Bitboard64();
		this.b = new Bitboard64();
		this.a = new Bitboard64();
	}
	Rand64() {
		let e = this.a.newMINUS(util_RKiss.Rotate(this.b,7));
		this.a = this.b.newXOR(util_RKiss.Rotate(this.c,13));
		this.b = this.c.newPLUS(util_RKiss.Rotate(this.d,37));
		this.c = this.d.newPLUS(e);
		this.d = e.newPLUS(this.a);
		return this.d;
	}
	SF_RKiss() {
		let seed = 73;
		this.a.Init(61930,24301);
		this.b.Init(54497,11383);
		this.c.Init(54497,11383);
		this.d.Init(54497,11383);
		let _g = 0;
		let _g1 = seed;
		while(_g < _g1) {
			let i = _g++;
			this.Rand64();
		}
	}
	static Rotate(x,k) {
		let tmpBB = x.newShiftL(k);
		tmpBB.OR(x.newShiftR(64 - k));
		return tmpBB;
	}
}
util_RKiss.__name__ = true;
class util_MathUtil {
	static abs(a) {
		if(a >= 0) {
			return a;
		} else {
			return -a;
		}
	}
	static max(a,b) {
		if(a > b) {
			return a;
		} else {
			return b;
		}
	}
	static min(a,b) {
		if(a < b) {
			return a;
		} else {
			return b;
		}
	}
	static zeroPadding(v) {
		let ereg_r = new RegExp("\\B(?=(\\d\\d\\d)+(?!\\d))","g".split("u").join(""));
		return ("" + v).replace(ereg_r,",");
	}
}
util_MathUtil.__name__ = true;
class util_StringUtil {
	static isNumberString(s) {
		let r = new EReg("[0-9]+","");
		return r.match(s);
	}
}
util_StringUtil.__name__ = true;
var $_;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
Bitboard.NA = 27;
Bitboard.NB = 54;
BB.ZERO_BB = new Bitboard();
BB.squareDistance = [];
BB.stepAttacksBB = [];
BB.betweenBB = [];
BB.lineBB = [];
BB.squareBB = [];
BB.enemyField1 = [];
BB.enemyField2 = [];
BB.enemyField3 = [];
BB.pawnLineBB = [];
BB.pseudoAttacks = [];
BB.pseudoQueenAttacks = [];
BB.RookStepEffectBB = [];
BB.BishopStepEffectBB = [];
BB.LanceStepEffectBB = [[]];
BB.initialized = false;
BB.steps = [[0,0,0,0,0,0,0,0,0],[-1,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,0],[7,-11,0,0,0,0,0,0,0],[-1,8,10,-10,-8,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[-1,8,9,1,-10,-9,0,0,0],[-1,8,9,1,-10,-9,10,-8,0],[-1,8,9,1,-10,-9,0,0,0],[-1,8,9,1,-10,-9,0,0,0],[-1,8,9,1,-10,-9,0,0,0],[-1,8,9,1,-10,-9,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]];
BB.rDeltas = [-1,-9,1,9];
BB.bDeltas = [-10,-8,10,8];
BB.fDeltas = [-1,1,0,0];
BB.nDeltas = [-1,0,0,0];
BB.sDeltas = [1,0,0,0];
EvalList.MAX_LENGTH = 40;
Evaluate.evalRootColour = 0;
Evaluate.pieceValue = [0,90,315,405,495,855,990,540,15000,540,540,540,540,945,1395,0,0,-90,-315,-405,-495,-855,-990,-540,-15000,-540,-540,-540,-540,-945,-1395];
Evaluate.capturePieceValue = [0,180,630,810,990,1710,1980,1080,15000,630,855,945,1035,1800,2385,0,0,180,630,810,990,1710,1980,1080,15000,630,855,945,1035,1800,2385];
Evaluate.proDiffPieceValue = [0,450,225,135,45,90,405,0,0];
Evaluate.FV_SCALE = 32;
Evaluate.our_effect_value = (function($this) {
	var $r;
	let this1 = new Array(9);
	$r = this1;
	return $r;
}(this));
Evaluate.their_effect_value = (function($this) {
	var $r;
	let this1 = new Array(9);
	$r = this1;
	return $r;
}(this));
Evaluate.storage_path = "https://storage.googleapis.com/knnshogi-haxe/";
LongEffect.BISHOP_DIR = 32 | 128 | 1 | 4;
LongEffect.ROOK_DIR = 2 | 8 | 16 | 64;
LongEffect.long_effect16_table = [0,0,8,0,0,LongEffect.BISHOP_DIR,LongEffect.ROOK_DIR,0,0,0,0,0,0,LongEffect.BISHOP_DIR,LongEffect.ROOK_DIR,0,0,0,16 << 8,0,0,LongEffect.BISHOP_DIR << 8,LongEffect.ROOK_DIR << 8,0,0,0,0,0,0,LongEffect.BISHOP_DIR << 8,LongEffect.ROOK_DIR << 8,0];
PSQTable.psqT = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
Position._hx_skip_constructor = false;
Position.psq = [];
Position.pieceValue = [0,90,315,405,495,855,990,540,15000,540,540,540,540,945,1395];
SFEN.startpos = "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1";
Types.TIME_LIMIT = 10;
Types.INT32_MAX = 2147483647;
Types.INT_MAX = 2147483647;
Types.VALUE_NOT_EVALUATED = 2147483647;
Types.ONE_PLY = 1;
Types.BLACK = 0;
Types.WHITE = 1;
Types.COLOR_NB = 2;
Types.ALL_PIECES = 0;
Types.PIECE_TYPE_NB = 15;
Types.PIECE_PROMOTE = 8;
Types.PIECE_WHITE = 16;
Types.PIECE_ZERO = 0;
Types.PIECE_HAND_NB = 8;
Types.NO_PIECE_TYPE = 0;
Types.PAWN = 1;
Types.LANCE = 2;
Types.KNIGHT = 3;
Types.SILVER = 4;
Types.BISHOP = 5;
Types.ROOK = 6;
Types.GOLD = 7;
Types.KING = 8;
Types.PRO_PAWN = 9;
Types.PRO_LANCE = 10;
Types.PRO_KNIGHT = 11;
Types.PRO_SILVER = 12;
Types.HORSE = 13;
Types.DRAGON = 14;
Types.NO_PIECE = 0;
Types.B_PAWN = 1;
Types.B_LANCE = 2;
Types.B_KNIGHT = 3;
Types.B_SILVER = 4;
Types.B_BISHOP = 5;
Types.B_ROOK = 6;
Types.B_GOLD = 7;
Types.B_KING = 8;
Types.B_PRO_PAWN = 9;
Types.B_PRO_LANCE = 10;
Types.B_PRO_KNIGHT = 11;
Types.B_PRO_SILVER = 12;
Types.B_HORSE = 13;
Types.B_DRAGON = 14;
Types.W_PAWN = 17;
Types.W_LANCE = 18;
Types.W_KNIGHT = 19;
Types.W_SILVER = 20;
Types.W_BISHOP = 21;
Types.W_ROOK = 22;
Types.W_GOLD = 23;
Types.W_KING = 24;
Types.W_PRO_PAWN = 25;
Types.W_PRO_LANCE = 26;
Types.W_PRO_KNIGHT = 27;
Types.W_PRO_SILVER = 28;
Types.W_HORSE = 29;
Types.W_DRAGON = 30;
Types.PIECE_NB = 31;
Types.SQ_11 = 0;
Types.SQ_HB = 80;
Types.SQ_NB = 81;
Types.SQ_NB_PLUS1 = 82;
Types.SQ_NONE = 81;
Types.FILE_1 = 0;
Types.FILE_2 = 1;
Types.FILE_3 = 2;
Types.FILE_4 = 3;
Types.FILE_5 = 4;
Types.FILE_6 = 5;
Types.FILE_7 = 6;
Types.FILE_8 = 7;
Types.FILE_9 = 8;
Types.FILE_NB = 9;
Types.RANK_1 = 0;
Types.RANK_2 = 1;
Types.RANK_3 = 2;
Types.RANK_4 = 3;
Types.RANK_5 = 4;
Types.RANK_6 = 5;
Types.RANK_7 = 6;
Types.RANK_8 = 7;
Types.RANK_9 = 8;
Types.RANK_NB = 9;
Types.MAX_MOVES = 600;
Types.MAX_PLY = 6;
Types.DELTA_N = -1;
Types.DELTA_E = -9;
Types.DELTA_S = 1;
Types.DELTA_W = 9;
Types.DELTA_NN = -2;
Types.DELTA_NE = -10;
Types.DELTA_SE = -8;
Types.DELTA_SS = 2;
Types.DELTA_SW = 10;
Types.DELTA_NW = 8;
Types.SQ_D = 1;
Types.SQ_R = -9;
Types.SQ_U = -1;
Types.SQ_L = 9;
Types.MOVE_NONE = 0;
Types.MOVE_NORMAL = 0;
Types.MOVE_DROP = 16384;
Types.MOVE_PROMO = 32768;
Types.VALUE_ZERO = 0;
Types.VALUE_DRAW = 0;
Types.VALUE_KNOWN_WIN = 15000;
Types.VALUE_MATE = 30000;
Types.VALUE_INFINITE = 30001;
Types.VALUE_MATE_IN_MAX_PLY = 29994;
Types.VALUE_MATED_IN_MAX_PLY = -29994;
Types.VALUE_NONE = 30002;
Types.PawnValue = 90;
Types.LanceValue = 315;
Types.KnightValue = 405;
Types.SilverValue = 495;
Types.GoldValue = 540;
Types.BishopValue = 855;
Types.RookValue = 990;
Types.ProPawnValue = 540;
Types.ProLanceValue = 540;
Types.ProKnightValue = 540;
Types.ProSilverValue = 540;
Types.HorseValue = 945;
Types.DragonValue = 1395;
Types.KingValue = 15000;
Types.flipSquare = [80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0];
Types.bbToSquare = [72,63,54,45,36,27,18,9,0,73,64,55,46,37,28,19,10,1,74,65,56,47,38,29,20,11,2,75,66,57,48,39,30,21,12,3,76,67,58,49,40,31,22,13,4,77,68,59,50,41,32,23,14,5,78,69,60,51,42,33,24,15,6,79,70,61,52,43,34,25,16,7,80,71,62,53,44,35,26,17,8];
Types.SquareToFile = [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,9];
Types.SquareToRank = [0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,9];
Types.sqww_table = [];
Types.direc_table = [[]];
Types.DirectToDeltaWW_ = [17284598,16776695,16268792,507903,-507903,-16268792,-16776695,-17284598];
Zobrist.zero = new Bitboard64(0,0);
Zobrist.side = new Bitboard64(1,0);
Zobrist.psq = (function($this) {
	var $r;
	let this1 = new Array(81);
	$r = this1;
	return $r;
}(this));
Zobrist.hand = (function($this) {
	var $r;
	let this1 = new Array(2);
	$r = this1;
	return $r;
}(this));
Zobrist.depth = (function($this) {
	var $r;
	let this1 = new Array(6);
	$r = this1;
	return $r;
}(this));
Main.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
