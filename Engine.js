// Generated by Haxe 4.1.4
(function ($global) { "use strict";
class Bitboard {
	constructor(l,m,u) {
		if(u == null) {
			u = 0;
		}
		if(m == null) {
			m = 0;
		}
		if(l == null) {
			l = 0;
		}
		this.needCount = false;
		this.count = 0;
		this.upper = 0;
		this.middle = 0;
		this.lower = 0;
		this.lower = l;
		this.middle = m;
		this.upper = u;
	}
	Clear() {
		this.lower = 0;
		this.middle = 0;
		this.upper = 0;
		this.count = 0;
		this.needCount = false;
	}
	Copy(other) {
		this.lower = other.lower;
		this.middle = other.middle;
		this.upper = other.upper;
		this.count = other.count;
		this.needCount = other.needCount;
	}
	newCOPY() {
		let newBB = new Bitboard();
		newBB.Copy(this);
		return newBB;
	}
	IsZero() {
		if(this.lower == 0 && this.middle == 0) {
			return this.upper == 0;
		} else {
			return false;
		}
	}
	IsNonZero() {
		if(!(this.lower != 0 || this.middle != 0)) {
			return this.upper != 0;
		} else {
			return true;
		}
	}
	isSet(sq) {
		if(sq < 27) {
			return (this.lower & 1 << sq) != 0;
		} else if(sq < 54) {
			return (this.middle & 1 << sq - 27) != 0;
		} else {
			return (this.upper & 1 << sq - 54) != 0;
		}
	}
	more_than_one() {
		if((this.lower & this.lower - 1) != 0 || (this.middle & this.middle - 1) != 0 || (this.upper & this.upper - 1) != 0 || this.lower != 0 && this.upper != 0 || this.lower != 0 && this.middle != 0 || this.middle != 0 && this.upper != 0) {
			return true;
		}
		return false;
	}
	LSB() {
		if(this.lower != 0) {
			return Bitboard.LeastSB(this.lower);
		}
		if(this.middle != 0) {
			return Bitboard.LeastSB(this.middle) + 27;
		}
		if(this.upper != 0) {
			return Bitboard.LeastSB(this.upper) + 54;
		}
		return -1;
	}
	OR(other) {
		this.lower |= other.lower;
		this.middle |= other.middle;
		this.upper |= other.upper;
		this.needCount = true;
	}
	newOR(other) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.OR(other);
		return newBB;
	}
	XOR(other) {
		this.lower ^= other.lower;
		this.middle ^= other.middle;
		this.upper ^= other.upper;
		this.needCount = true;
	}
	newXOR(other) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.XOR(other);
		return newBB;
	}
	PopLSB() {
		let index = -1;
		if(this.lower != 0) {
			this.count--;
			index = Bitboard.LeastSB(this.lower);
			this.lower &= this.lower - 1;
			return index;
		}
		if(this.middle != 0) {
			this.count--;
			index = 27 + Bitboard.LeastSB(this.middle);
			this.middle &= this.middle - 1;
			return index;
		}
		if(this.upper != 0) {
			this.count--;
			index = 54 + Bitboard.LeastSB(this.upper);
			this.upper &= this.upper - 1;
			return index;
		}
		return -1;
	}
	ShiftL(theShift) {
		if(theShift < 27) {
			this.upper <<= theShift;
			this.upper |= this.middle >>> 27 - theShift;
			this.middle <<= theShift;
			this.middle |= this.lower >>> 27 - theShift;
			this.lower <<= theShift;
		} else if(theShift < 54) {
			this.upper = this.middle >>> theShift - 27;
			this.upper |= this.lower >>> 54 - theShift;
			this.middle = this.lower << theShift - 27;
			this.lower = 0;
		} else {
			this.upper = this.lower << theShift - 54;
			this.lower = 0;
		}
		this.needCount = true;
	}
	newShiftL(theShift) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.ShiftL(theShift);
		return newBB;
	}
	ShiftR(theShift) {
		if(theShift < 27) {
			this.lower >>>= theShift;
			this.lower |= this.middle << 27 - theShift >>> 27 - theShift << 27 - theShift;
			this.middle >>>= theShift;
			this.middle |= this.upper << 27 - theShift >>> 27 - theShift << 27 - theShift;
			this.upper >>>= theShift;
		} else if(theShift < 54) {
			this.lower = this.middle >>> theShift - 27;
			this.lower |= this.upper << 27 - theShift >>> 27 - theShift << 27 - theShift;
			this.middle = this.upper >>> theShift - 27;
			this.upper = 0;
		} else {
			this.lower = this.upper >>> theShift - 54;
			this.middle = 0;
			this.upper = 0;
		}
		this.needCount = true;
	}
	newShiftR(theShift) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.ShiftR(theShift);
		return newBB;
	}
	SetBit(theIndex) {
		if(theIndex < 27) {
			this.lower |= 1 << theIndex;
		} else if(theIndex < 54) {
			this.middle |= 1 << theIndex - 27;
		} else {
			this.upper |= 1 << theIndex - 54;
		}
		this.needCount = true;
	}
	ClrBit(theIndex) {
		if(theIndex < 27) {
			this.lower ^= 1 << theIndex;
		} else if(theIndex < 54) {
			this.middle ^= 1 << theIndex - 27;
		} else {
			this.upper ^= 1 << theIndex - 54;
		}
		this.needCount = true;
	}
	NORM27() {
		this.lower &= 134217727;
		this.middle &= 134217727;
		this.upper &= 134217727;
		this.needCount = true;
		return this;
	}
	AND(other) {
		this.lower &= other.lower;
		this.middle &= other.middle;
		this.upper &= other.upper;
		this.needCount = true;
	}
	newAND(other) {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.AND(other);
		return newBB;
	}
	NOT() {
		this.lower = ~this.lower;
		this.middle = ~this.middle;
		this.upper = ~this.upper;
		this.count = 81 - this.count;
	}
	newNOT() {
		let newBB = new Bitboard();
		newBB.Copy(this);
		newBB.NOT();
		return newBB;
	}
	toStringBB() {
		let s = "";
		let _g = 0;
		while(_g < 81) {
			let i = _g++;
			let f = 8 - i % 9;
			let r = i / 9 | 0;
			let sq = f * 9 + r;
			if(i % 9 == 0) {
				s += "\n";
			}
			if(this.isSet(sq)) {
				s += "1";
			} else {
				s += "0";
			}
		}
		return s;
	}
	static LeastSB(theInt) {
		let i = -1;
		if((theInt & 65535) == 0) {
			i += 16;
			theInt >>>= 16;
		}
		if((theInt & 255) == 0) {
			i += 8;
			theInt >>>= 8;
		}
		if((theInt & 15) == 0) {
			i += 4;
			theInt >>>= 4;
		}
		if((theInt & 3) == 0) {
			i += 2;
			theInt >>>= 2;
		}
		if((theInt & 1) == 0) {
			++i;
			theInt >>>= 1;
		}
		if((theInt & 1) != 0) {
			++i;
		}
		return i;
	}
}
Bitboard.__name__ = true;
class BB {
	static SquareDistance(s1,s2) {
		return BB.squareDistance[s1][s2];
	}
	static FileDistance(s1,s2) {
		return util_MathUtil.abs(Types.file_of(s1) - Types.file_of(s2));
	}
	static RankDistance(s1,s2) {
		return util_MathUtil.abs(Types.rank_of(s1) - Types.rank_of(s2));
	}
	static Init() {
		haxe_Log.trace("Init::BB",{ fileName : "BB.hx", lineNumber : 64, className : "BB", methodName : "Init"});
		if(BB.initialized) {
			return;
		}
		BB.filesBB = [];
		BB.ranksBB = [];
		let _g = 0;
		while(_g < 9) {
			let i = _g++;
			BB.filesBB.push(new Bitboard(511,0,0));
			BB.filesBB[i].ShiftL(9 * i);
			BB.ranksBB.push(new Bitboard(262657,262657,262657));
			BB.ranksBB[i].ShiftL(i);
		}
		BB.enemyField1[1] = BB.ranksBB[8].newCOPY();
		BB.enemyField1[0] = BB.ranksBB[0].newCOPY();
		BB.enemyField2[1] = BB.ranksBB[8].newOR(BB.ranksBB[7]);
		BB.enemyField2[0] = BB.ranksBB[0].newOR(BB.ranksBB[1]);
		BB.enemyField3[1] = BB.enemyField2[1].newOR(BB.ranksBB[6]);
		BB.enemyField3[0] = BB.enemyField2[0].newOR(BB.ranksBB[2]);
		BB.pawnLineBB[0] = new Bitboard();
		BB.pawnLineBB[1] = new Bitboard();
		let _g1 = 0;
		while(_g1 < 82) {
			let sq = _g1++;
			Types.sqww_table[sq] = 138412288 + Types.file_of(sq) * -16776695 + Types.rank_of(sq) * -507903;
		}
		let _g2 = 0;
		while(_g2 < 81) {
			let sq1 = _g2++;
			Types.direc_table[sq1] = [];
			let _g = 0;
			let _g1 = 8;
			while(_g < _g1) {
				let dir = _g++;
				let delta = Types.DirectToDeltaWW(dir);
				let sq2 = (Types.to_sqww(sq1) | 0) + (delta | 0);
				while(Types.is_ok(sq2)) {
					Types.direc_table[sq1][Types.sqww_to_sq(sq2)] = Types.to_directions(dir);
					sq2 += delta;
				}
			}
		}
		let _g3 = 0;
		while(_g3 < 81) {
			let sq = _g3++;
			BB.squareBB[sq] = new Bitboard();
			BB.squareBB[sq].SetBit(sq);
		}
		let _g4 = 0;
		while(_g4 < 81) {
			let s1 = _g4++;
			BB.squareDistance[s1] = [];
			let _g = 0;
			while(_g < 81) {
				let s2 = _g++;
				BB.squareDistance[s1][s2] = util_MathUtil.max(BB.FileDistance(s1,s2),BB.RankDistance(s1,s2));
			}
		}
		let this1 = 0;
		let pt = this1;
		let _g5 = 0;
		let _g6 = 31;
		while(_g5 < _g6) {
			let p = _g5++;
			let this1 = p;
			pt = this1;
			BB.stepAttacksBB[pt] = [];
			let _g = 0;
			while(_g < 81) {
				let s1 = _g++;
				BB.stepAttacksBB[pt][s1] = new Bitboard();
			}
		}
		let s = 0;
		let _g7 = 0;
		let _g8 = 15;
		while(_g7 < _g8) {
			let pt = _g7++;
			BB.pseudoAttacks[pt] = [];
		}
		let _g9 = 0;
		while(_g9 < 81) {
			let s = _g9++;
			let a = BB.AttacksBB(s,new Bitboard(),5);
			BB.pseudoAttacks[5][s] = BB.AttacksBB(s,new Bitboard(),5);
			BB.pseudoAttacks[6][s] = BB.AttacksBB(s,new Bitboard(),6);
			BB.pseudoAttacks[13][s] = BB.AttacksBB(s,new Bitboard(),13);
			BB.pseudoAttacks[14][s] = BB.AttacksBB(s,new Bitboard(),14);
			BB.RookStepEffectBB[s] = BB.pseudoAttacks[6][s].newOR(BB.squareBB[s]);
			BB.BishopStepEffectBB[s] = BB.pseudoAttacks[5][s].newOR(BB.squareBB[s]);
			BB.pseudoQueenAttacks[s] = new Bitboard();
			BB.pseudoQueenAttacks[s].OR(BB.pseudoAttacks[5][s]);
			BB.pseudoQueenAttacks[s].OR(BB.pseudoAttacks[6][s]);
		}
		let _g10 = 0;
		while(_g10 < 81) {
			let s1 = _g10++;
			BB.betweenBB[s1] = [];
			BB.lineBB[s1] = [];
			let _g = 0;
			while(_g < 81) {
				let s2 = _g++;
				BB.betweenBB[s1][s2] = new Bitboard();
				BB.lineBB[s1][s2] = new Bitboard();
				if(BB.pseudoQueenAttacks[s1].newAND(BB.squareBB[s2]).IsNonZero()) {
					let deltta = (s2 - s1) / BB.SquareDistance(s1,s2) | 0;
					s = s1 + deltta;
					while(s != s2) {
						BB.betweenBB[s1][s2].OR(BB.squareBB[s]);
						s += deltta;
					}
					pt = 6;
					if(BB.pseudoAttacks[5][s1].newAND(BB.squareBB[s2]).IsNonZero()) {
						pt = 5;
					}
					BB.lineBB[s1][s2].Copy(BB.pseudoAttacks[pt][s1]);
					BB.lineBB[s1][s2].AND(BB.pseudoAttacks[pt][s2]);
					BB.lineBB[s1][s2].OR(BB.squareBB[s1]);
					BB.lineBB[s1][s2].OR(BB.squareBB[s2]);
				}
			}
		}
		let c = 0;
		let _g11 = 1;
		let _g12 = 14;
		while(_g11 < _g12) {
			let p = _g11++;
			let this1 = p;
			pt = this1;
			let _g = 0;
			while(_g < 81) {
				let s = _g++;
				let _g1 = 0;
				while(_g1 < 9) {
					let k = _g1++;
					if(BB.steps[pt][k] == 0) {
						continue;
					}
					let to = s + BB.steps[pt][k];
					if(Types.Is_SqOK(to) == false) {
						continue;
					}
					let tmp;
					if(BB.SquareDistance(s,to) >= 3) {
						let this1 = Types.RawTypeOf(pt);
						tmp = this1 != 2;
					} else {
						tmp = false;
					}
					if(tmp) {
						continue;
					}
					BB.stepAttacksBB[Types.Make_Piece(c,pt)][s].OR(BB.squareBB[to]);
				}
			}
		}
		let c1 = 1;
		let _g13 = 1;
		let _g14 = 14;
		while(_g13 < _g14) {
			let p = _g13++;
			let this1 = p;
			pt = this1;
			let _g = 0;
			while(_g < 81) {
				let s = _g++;
				let _g1 = 0;
				while(_g1 < 9) {
					let k = _g1++;
					if(BB.steps[pt][k] == 0) {
						continue;
					}
					let to = s - BB.steps[pt][k];
					if(Types.Is_SqOK(to) == false) {
						continue;
					}
					let tmp;
					if(BB.SquareDistance(s,to) >= 3) {
						let this1 = Types.RawTypeOf(pt);
						tmp = this1 != 2;
					} else {
						tmp = false;
					}
					if(tmp) {
						continue;
					}
					BB.stepAttacksBB[Types.Make_Piece(c1,pt)][s].OR(BB.squareBB[to]);
				}
			}
		}
		BB.LanceStepEffectBB[0] = [];
		let _g15 = 0;
		while(_g15 < 81) {
			let s = _g15++;
			BB.LanceStepEffectBB[0][s] = BB.stepAttacksBB[Types.Make_Piece(0,2)][s].newOR(BB.squareBB[s]).newAND(BB.RookStepEffectBB[s]);
		}
		BB.LanceStepEffectBB[1] = [];
		let _g16 = 0;
		while(_g16 < 81) {
			let s = _g16++;
			BB.LanceStepEffectBB[1][s] = BB.stepAttacksBB[Types.Make_Piece(1,2)][s].newOR(BB.squareBB[s]).newAND(BB.RookStepEffectBB[s]);
		}
		BB.initialized = true;
	}
	static getStepAttacksBB(pc,sq) {
		return BB.stepAttacksBB[pc][sq];
	}
	static kingEffect(sq) {
		return BB.stepAttacksBB[8][sq];
	}
	static pawnEffect(c,sq) {
		return BB.stepAttacksBB[Types.Make_Piece(c,1)][sq];
	}
	static knightEffect(c,sq) {
		return BB.stepAttacksBB[Types.Make_Piece(c,3)][sq];
	}
	static silverEffect(c,sq) {
		return BB.stepAttacksBB[Types.Make_Piece(c,4)][sq];
	}
	static goldEffect(c,sq) {
		return BB.stepAttacksBB[Types.Make_Piece(c,7)][sq];
	}
	static cross00StepEffect(sq) {
		return BB.rookStepEffect(sq).newAND(BB.kingEffect(sq));
	}
	static cross45StepEffect(sq) {
		return BB.bishopStepEffect(sq).newAND(BB.kingEffect(sq));
	}
	static rookFileEffect(sq,occupied) {
		return BB.SlidingAttack(BB.fDeltas,sq,occupied);
	}
	static lanceEffect(c,sq,occupied) {
		if(c == 0) {
			return BB.SlidingAttack(BB.nDeltas,sq,occupied);
		} else {
			return BB.SlidingAttack(BB.sDeltas,sq,occupied);
		}
	}
	static bishopEffect(sq,occupied) {
		return BB.SlidingAttack(BB.bDeltas,sq,occupied);
	}
	static rookEffect(sq,occupied) {
		return BB.SlidingAttack(BB.rDeltas,sq,occupied);
	}
	static horseEffect(sq,occupied) {
		return BB.SlidingGoldenAttack(BB.bDeltas,sq,occupied);
	}
	static dragonEffect(sq,occupied) {
		return BB.SlidingGoldenAttack(BB.rDeltas,sq,occupied);
	}
	static rookStepEffect(sq) {
		return BB.RookStepEffectBB[sq];
	}
	static bishopStepEffect(sq) {
		return BB.BishopStepEffectBB[sq];
	}
	static lanceStepEffect(c,sq) {
		return BB.LanceStepEffectBB[c][sq];
	}
	static AttacksBB(sq,occ,pt) {
		switch(pt) {
		case 2:
			return BB.SlidingAttack(BB.rDeltas,sq,occ);
		case 5:
			return BB.SlidingAttack(BB.bDeltas,sq,occ);
		case 6:
			return BB.SlidingAttack(BB.rDeltas,sq,occ);
		case 13:
			return BB.SlidingGoldenAttack(BB.bDeltas,sq,occ);
		case 14:
			return BB.SlidingGoldenAttack(BB.rDeltas,sq,occ);
		default:
			return new Bitboard();
		}
	}
	static SlidingAttack(deltas,sq,occ) {
		let attack = new Bitboard();
		let _g = 0;
		while(_g < 4) {
			let i = _g++;
			if(deltas[i] == 0) {
				return attack;
			}
			let s = sq + deltas[i];
			while(Types.Is_SqOK(s) && BB.SquareDistance(s,s - deltas[i]) == 1) {
				attack.OR(BB.squareBB[s]);
				if(occ.newAND(BB.squareBB[s]).IsNonZero()) {
					break;
				}
				s += deltas[i];
			}
		}
		return attack;
	}
	static SlidingGoldenAttack(deltas,sq,occ) {
		let attack = BB.stepAttacksBB[8][sq].newCOPY();
		let _g = 0;
		while(_g < 4) {
			let i = _g++;
			if(deltas[i] == 0) {
				return attack;
			}
			let s = sq + deltas[i];
			while(Types.Is_SqOK(s) && BB.SquareDistance(s,s - deltas[i]) == 1) {
				attack.OR(BB.squareBB[s]);
				if(occ.newAND(BB.squareBB[s]).IsNonZero()) {
					break;
				}
				s += deltas[i];
			}
		}
		return attack;
	}
	static ShiftBB(b,deltta) {
		if(deltta == -1) {
			return b.newShiftR(1);
		}
		if(deltta == 1) {
			return b.newShiftL(1);
		}
		if(deltta == -10) {
			return b.newAND(BB.filesBB[8].newNOT()).newShiftL(10);
		}
		if(deltta == -8) {
			return b.newAND(BB.filesBB[8].newNOT()).newShiftR(8);
		}
		if(deltta == 8) {
			return b.newAND(BB.filesBB[0].newNOT()).newShiftL(8);
		}
		if(deltta == 10) {
			return b.newAND(BB.filesBB[0].newNOT()).newShiftR(10);
		}
		let zero = new Bitboard();
		return zero;
	}
	static ANDsq(b,sq) {
		return b.newAND(BB.squareBB[sq]);
	}
}
BB.__name__ = true;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
}
EReg.__name__ = true;
class Engine {
	constructor() {
		haxe_Log.trace("Engine:new",{ fileName : "Engine.hx", lineNumber : 12, className : "Engine", methodName : "new"});
	}
	static main() {
		haxe_Log.trace("Engine main",{ fileName : "Engine.hx", lineNumber : 16, className : "Engine", methodName : "main"});
		Engine.pos = new Position();
		Engine.Init();
		Engine.global.onmessage = Engine.onMessage;
	}
	static Init() {
		BB.Init();
		Position.Init();
		Evaluate.Init();
		Search.Init();
	}
	static onMessage(m) {
		let msg = m.data;
		let res = "";
		haxe_Log.trace("Endine get data = " + msg,{ fileName : "Engine.hx", lineNumber : 32, className : "Engine", methodName : "onMessage"});
		if(msg.indexOf("position ") == 0) {
			res = Engine.doThink(msg);
		}
		Engine.global.postMessage(res);
	}
	static doThink(msg) {
		Engine.pos.setPosition(HxOverrides.substr(msg,9,null));
		Engine.pos.printBoard();
		haxe_Log.trace("Engine::doThink pos.c: " + Engine.pos.SideToMove(),{ fileName : "Engine.hx", lineNumber : 42, className : "Engine", methodName : "doThink"});
		Search.Reset(Engine.pos);
		Search.Think();
		let moveResult = Search.rootMoves[0].pv[0];
		let res = "bestmove " + Types.Move_To_String(moveResult);
		haxe_Log.trace(res,{ fileName : "Engine.hx", lineNumber : 47, className : "Engine", methodName : "doThink"});
		return res;
	}
}
Engine.__name__ = true;
class EvalSum {
	constructor() {
		this.p = [[0,0],[0,0],[0,0]];
		this.m = [];
	}
	sum(c) {
		let scoreBoard = this.p[0][0] - this.p[1][0] + this.p[2][0];
		let scoreTurn = this.p[2][1];
		return (c == 0 ? scoreBoard : -scoreBoard) + scoreTurn;
	}
}
EvalSum.__name__ = true;
class ExtBonaPiece {
	constructor(b,w) {
		this.fb = b;
		this.fw = w;
	}
}
ExtBonaPiece.__name__ = true;
class EvalList {
	constructor() {
		this.piece_no_list_hand = [];
		this.piece_no_list_board = new Array(82);
		this.pieceListFw = new Array(40);
		this.pieceListFb = new Array(40);
		this.kpp_hand_index = [[new ExtBonaPiece(0,0),new ExtBonaPiece(1,20),new ExtBonaPiece(39,44),new ExtBonaPiece(49,54),new ExtBonaPiece(59,64),new ExtBonaPiece(79,82),new ExtBonaPiece(85,88),new ExtBonaPiece(69,74)],[new ExtBonaPiece(0,0),new ExtBonaPiece(20,1),new ExtBonaPiece(44,39),new ExtBonaPiece(54,49),new ExtBonaPiece(64,59),new ExtBonaPiece(82,79),new ExtBonaPiece(88,85),new ExtBonaPiece(74,69)]];
		this.kpp_board_index = [new ExtBonaPiece(0,0),new ExtBonaPiece(90,90 + 81),new ExtBonaPiece(90 + 81 + 81,90 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(0,0),new ExtBonaPiece(0,0),new ExtBonaPiece(90 + 81,90),new ExtBonaPiece(90 + 81 + 81 + 81,90 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81,90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),new ExtBonaPiece(0,0)];
		let _g = 0;
		let _g1 = this.length();
		while(_g < _g1) {
			let i = _g++;
			this.pieceListFb[i] = 0;
			this.pieceListFw[i] = 0;
		}
	}
	piece_list_fb() {
		return this.pieceListFb;
	}
	piece_list_fw() {
		return this.pieceListFw;
	}
	length() {
		return 38;
	}
	put_piece(piece_no,sq,pc) {
		this.set_piece_on_board(piece_no,this.kpp_board_index[pc].fb + sq,this.kpp_board_index[pc].fw + Types.Inv(sq),sq);
	}
	put_piece_hand(piece_no,c,pt,i) {
		this.set_piece_on_hand(piece_no,this.kpp_hand_index[c][pt].fb + i,this.kpp_hand_index[c][pt].fw + i);
	}
	piece_no_of_hand(bp) {
		return this.piece_no_list_hand[bp];
	}
	piece_no_of_board(sq) {
		return this.piece_no_list_board[sq];
	}
	printPieceNo() {
		haxe_Log.trace("EvalList::print",{ fileName : "Evaluate.hx", lineNumber : 180, className : "EvalList", methodName : "printPieceNo"});
		let str = "--- print PieceNo ---";
		let _g = 0;
		while(_g < 81) {
			let i = _g++;
			if(i % 9 == 0) {
				str += "\n";
			}
			let s = this.piece_no_list_board[Types.bbToSquare[i]];
			if(isNaN(s)) {
				str += " - ";
			} else {
				str += HxOverrides.substr(" " + this.piece_no_list_board[Types.bbToSquare[i]] + " ",-3,null);
			}
		}
		haxe_Log.trace("" + str,{ fileName : "Evaluate.hx", lineNumber : 194, className : "EvalList", methodName : "printPieceNo"});
		haxe_Log.trace("piece_no_list_hand: " + Std.string(this.piece_no_list_hand),{ fileName : "Evaluate.hx", lineNumber : 195, className : "EvalList", methodName : "printPieceNo"});
	}
	set_piece_on_board(piece_no,fb,fw,sq) {
		this.pieceListFb[piece_no] = fb;
		this.pieceListFw[piece_no] = fw;
		this.piece_no_list_board[sq] = piece_no;
	}
	set_piece_on_hand(piece_no,fb,fw) {
		this.pieceListFb[piece_no] = fb;
		this.pieceListFw[piece_no] = fw;
		this.piece_no_list_hand[fb] = piece_no;
	}
}
EvalList.__name__ = true;
class DirtyPiece {
	constructor() {
		this.dirty_num = 0;
		this.pieceNo = new Array(2);
	}
}
DirtyPiece.__name__ = true;
class Evaluate {
	static Init() {
		haxe_Log.trace("Evaluate::Init " + (90 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81 + 81),{ fileName : "Evaluate.hx", lineNumber : 309, className : "Evaluate", methodName : "Init"});
		let _g = 0;
		while(_g < 9) {
			let i = _g++;
			Evaluate.our_effect_value[i] = 69632 / (i + 1) | 0;
			Evaluate.their_effect_value[i] = 98304 / (i + 1) | 0;
		}
	}
	static compute_eval_impl(pos) {
		let sum = new EvalSum();
		let st = pos.state();
		let score = st.materialValue;
		sum.p[0][0] = sum.p[1][0] = 0;
		sum.p[2][0] = 0;
		sum.p[2][1] = 0;
		let this1 = new Array(2);
		let effects = this1;
		let _g = 0;
		while(_g < 81) {
			let sq = _g++;
			effects[0] = pos.board_effect[0].effect(sq);
			effects[1] = pos.board_effect[1].effect(sq);
			let king_sq = pos.king_square(0);
			let d = Types.dist(sq,king_sq);
			let s1 = effects[0] * Evaluate.our_effect_value[d] / 1024 | 0;
			let s2 = effects[Types.OppColour(0)] * Evaluate.their_effect_value[d] / 1024 | 0;
			let king_sq1 = pos.king_square(1);
			let d1 = Types.dist(sq,king_sq1);
			let s11 = effects[1] * Evaluate.our_effect_value[d1] / 1024 | 0;
			let s21 = effects[Types.OppColour(1)] * Evaluate.their_effect_value[d1] / 1024 | 0;
			let pc = pos.piece_on(sq);
			if(pc == 0) {
				continue;
			}
			let piece_value = Evaluate.pieceValue[pc];
		}
		sum.p[2][0] += score * 32;
		st.sum = sum;
	}
	static compute_eval(pos) {
		Evaluate.compute_eval_impl(pos);
		return pos.state().sum.sum(pos.side_to_move()) / 32 | 0;
	}
	static evaluateBody(pos) {
		Evaluate.compute_eval_impl(pos);
	}
	static DoEvaluate(pos,doTrace) {
		Evaluate.compute_eval(pos);
		let st = pos.state();
		let sum = st.sum;
		return sum.sum(pos.side_to_move()) / 32 | 0;
	}
}
Evaluate.__name__ = true;
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = true;
class ByteBoard {
	constructor() {
		this.e = new Array(82);
		this.clear();
	}
	clear() {
		let _g = 0;
		while(_g < 82) {
			let i = _g++;
			this.e[i] = 0;
		}
	}
	effect(sq) {
		return this.e[sq];
	}
}
ByteBoard.__name__ = true;
class WordBoard {
	constructor() {
		this.le16 = new Array(82);
		this.clear();
	}
	clear() {
		let _g = 0;
		while(_g < 82) {
			let i = _g++;
			this.le16[i] = new LongEffect16();
		}
	}
	long_effect16(sq) {
		return this.le16[sq].u16;
	}
}
WordBoard.__name__ = true;
class LongEffect16 {
	constructor() {
		this.dirs = new Array(2);
	}
}
LongEffect16.__name__ = true;
class LongEffect {
	static long_effect16_of(pc) {
		return LongEffect.long_effect16_table[pc];
	}
	static init(pos) {
		haxe_Log.trace("Longeffect::init",{ fileName : "LongEffect.hx", lineNumber : 75, className : "LongEffect", methodName : "init"});
		pos.board_effect[0] = new ByteBoard();
		pos.board_effect[1] = new ByteBoard();
		pos.long_effect = new WordBoard();
	}
	static calc_effect(pos) {
		let board_effect = pos.board_effect;
		let long_effect = pos.long_effect;
		board_effect[0].clear();
		board_effect[1].clear();
		long_effect.clear();
		let b = pos.PiecesAll().newCOPY();
		while(b.IsNonZero()) {
			let sq = b.PopLSB();
			let pc = pos.piece_on(sq);
			let effect = LongEffect.effects_from(pc,sq,pos.pieces());
			let c = Types.color_of(pc);
			let eb = effect.newCOPY();
			while(eb.IsNonZero()) {
				let to = eb.PopLSB();
				pos.ADD_BOARD_EFFECT(c,to,1);
			}
			if(Types.has_long_effect(pc)) {
				if(Types.type_of(pc) != 2) {
					let this1 = pc & -9;
					effect = LongEffect.effects_from(this1,sq,pos.pieces());
				}
				eb = effect.newCOPY();
				while(eb.IsNonZero()) {
					let to = eb.PopLSB();
					let dir = Types.directions_of(sq,to);
					long_effect.le16[to].dirs[c] ^= dir;
				}
			}
		}
	}
	static short_effects_from(pc,sq) {
		switch(pc) {
		case 1:
			return BB.pawnEffect(0,sq);
		case 2:case 5:case 6:
			return BB.ZERO_BB;
		case 3:
			return BB.knightEffect(0,sq);
		case 4:
			return BB.silverEffect(0,sq);
		case 7:case 9:case 10:case 11:case 12:
			return BB.goldEffect(0,sq);
		case 13:case 29:
			return BB.cross00StepEffect(sq);
		case 17:
			return BB.pawnEffect(1,sq);
		case 19:
			return BB.knightEffect(1,sq);
		case 20:
			return BB.silverEffect(1,sq);
		case 18:case 21:case 22:
			return BB.ZERO_BB;
		case 8:case 24:
			return BB.kingEffect(sq);
		case 23:case 25:case 26:case 27:case 28:
			return BB.goldEffect(1,sq);
		case 14:case 30:
			return BB.cross45StepEffect(sq);
		default:
			return BB.ZERO_BB;
		}
	}
	static UPDATE_LONG_EFFECT_FROM_(pos,EFFECT_FUNC,to,dir_bw_us,dir_bw_others,p) {
		let Us = pos.sideToMove;
		let sq;
		let dir_bw = dir_bw_us ^ dir_bw_others;
		let toww = Types.to_sqww(to);
		while(dir_bw > 0) {
			let dir = Bitboard.LeastSB(dir_bw) & 7;
			let value = 1 << dir | 1 << dir + 8;
			value &= dir_bw;
			dir_bw &= ~value;
			let delta = Types.DirectToDeltaWW(dir);
			let the_same_color = Us == 0 && (value & 255) != 0 || Us == 1 && (value & 65280) != 0;
			let e1 = (dir_bw_us & value) != 0 ? p : the_same_color ? -p : 0;
			let not_the_same = Us == 0 && (value & 65280) != 0 || Us == 1 && (value & 255) != 0;
			let e2 = not_the_same ? -p : 0;
			let toww2 = toww;
			while(true) {
				toww2 += delta;
				if(!Types.is_ok(toww2)) {
					break;
				}
				sq = Types.sqww_to_sq(toww2);
				pos.long_effect.le16[sq].u16 ^= value;
				EFFECT_FUNC(pos,Us,sq,e1,e2);
				if(!(pos.piece_on(sq) == 0)) {
					break;
				}
			}
		}
	}
	static UPDATE_LONG_EFFECT_FROM(pos,to,dir_bw_us,dir_bw_others,p) {
		LongEffect.UPDATE_LONG_EFFECT_FROM_(pos,LongEffect.ADD_BOARD_EFFECT_BOTH,to,dir_bw_us,dir_bw_others,p);
	}
	static UPDATE_LONG_EFFECT_FROM_REWIND(pos,to,dir_bw_us,dir_bw_others,p) {
		LongEffect.UPDATE_LONG_EFFECT_FROM_(pos,LongEffect.ADD_BOARD_EFFECT_BOTH_REWIND,to,dir_bw_us,dir_bw_others,p);
	}
	static update_by_capturing_piece(pos,from,to,moved_pc,moved_after_pc,captured_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let long_effect = pos.long_effect;
		let dec_target = LongEffect.short_effects_from(moved_pc,from).newCOPY();
		let inc_target = LongEffect.short_effects_from(moved_after_pc,to).newCOPY();
		let and_target = inc_target.newAND(dec_target);
		inc_target.XOR(and_target);
		dec_target.XOR(and_target);
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Us,sq,1);
		}
		while(dec_target.IsNonZero()) {
			let sq = dec_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Us,sq,-1);
		}
		dec_target = LongEffect.short_effects_from(captured_pc,to).newCOPY();
		while(dec_target.IsNonZero()) {
			let sq = dec_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Types.OppColour(Us),sq,-1);
		}
		let dir = Types.directions_of(from,to);
		let dir_mask;
		if(dir != 0) {
			let dir_cont = 1 << 7 - Bitboard.LeastSB(dir);
			dir_mask = ~(dir_cont | dir_cont << 8);
		} else {
			dir_mask = 65535;
		}
		let dir_bw_us = LongEffect.long_effect16_of(moved_pc) & dir_mask;
		let dir_bw_others = pos.long_effect.long_effect16(from) & dir_mask;
		LongEffect.UPDATE_LONG_EFFECT_FROM(pos,from,dir_bw_us,dir_bw_others,-1);
		dir_bw_us = LongEffect.long_effect16_of(moved_after_pc);
		dir_bw_others = LongEffect.long_effect16_of(captured_pc);
		LongEffect.UPDATE_LONG_EFFECT_FROM(pos,to,dir_bw_us,dir_bw_others,1);
	}
	static update_by_no_capturing_piece(pos,from,to,moved_pc,moved_after_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let long_effect = pos.long_effect;
		let dec_target = LongEffect.short_effects_from(moved_pc,from).newCOPY();
		let inc_target = LongEffect.short_effects_from(moved_after_pc,to).newCOPY();
		let and_target = inc_target.newAND(dec_target);
		inc_target.XOR(and_target);
		dec_target.XOR(and_target);
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Us,sq,1);
		}
		while(dec_target.IsNonZero()) {
			let sq = dec_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Us,sq,-1);
		}
		let dir = Types.directions_of(from,to);
		let dir_mask;
		if(dir != 0) {
			let dir_cont = 1 << 7 - Bitboard.LeastSB(dir);
			dir_mask = ~(dir_cont | dir_cont << 8);
		} else {
			dir_mask = 65535;
		}
		let dir_bw_us = LongEffect.long_effect16_of(moved_pc) & dir_mask;
		let dir_bw_others = pos.long_effect.long_effect16(from) & dir_mask;
		LongEffect.UPDATE_LONG_EFFECT_FROM(pos,from,dir_bw_us,dir_bw_others,-1);
		dir_bw_us = LongEffect.long_effect16_of(moved_after_pc);
		dir_bw_others = pos.long_effect.long_effect16(to);
		LongEffect.UPDATE_LONG_EFFECT_FROM(pos,to,dir_bw_us,dir_bw_others,1);
	}
	static update_by_dropping_piece(pos,to,dropped_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let inc_target = LongEffect.short_effects_from(dropped_pc,to).newCOPY();
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			pos.ADD_BOARD_EFFECT(Us,sq,1);
		}
		let long_effect = pos.long_effect;
		let dir_bw_us = LongEffect.long_effect16_of(dropped_pc);
		let dir_bw_others = pos.long_effect.long_effect16(to);
		LongEffect.UPDATE_LONG_EFFECT_FROM(pos,to,dir_bw_us,dir_bw_others,1);
	}
	static rewind_by_dropping_piece(pos,to,dropped_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let inc_target = LongEffect.short_effects_from(dropped_pc,to).newCOPY();
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Us,sq,-1);
		}
		let long_effect = pos.long_effect;
		let dir_bw_us = LongEffect.long_effect16_of(dropped_pc);
		let dir_bw_others = pos.long_effect.long_effect16(to);
		LongEffect.UPDATE_LONG_EFFECT_FROM_REWIND(pos,to,dir_bw_us,dir_bw_others,-1);
	}
	static rewind_by_capturing_piece(pos,from,to,moved_pc,moved_after_pc,captured_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let long_effect = pos.long_effect;
		let inc_target = LongEffect.short_effects_from(moved_pc,from).newCOPY();
		let dec_target = LongEffect.short_effects_from(moved_after_pc,to).newCOPY();
		let and_target = inc_target.newAND(dec_target);
		inc_target.XOR(and_target);
		dec_target.XOR(and_target);
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Us,sq,1);
		}
		while(dec_target.IsNonZero()) {
			let sq = dec_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Us,sq,-1);
		}
		inc_target = LongEffect.short_effects_from(captured_pc,to).newCOPY();
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Types.OppColour(Us),sq,1);
		}
		let dir_bw_us = LongEffect.long_effect16_of(moved_after_pc);
		let dir_bw_others = LongEffect.long_effect16_of(captured_pc);
		LongEffect.UPDATE_LONG_EFFECT_FROM_REWIND(pos,to,dir_bw_us,dir_bw_others,-1);
		let dir = Types.directions_of(from,to);
		let dir_mask;
		if(dir != 0) {
			let dir_cont = 1 << 7 - Bitboard.LeastSB(dir);
			dir_mask = ~(dir_cont | dir_cont << 8);
		} else {
			dir_mask = 65535;
		}
		dir_bw_us = LongEffect.long_effect16_of(moved_pc) & dir_mask;
		dir_bw_others = pos.long_effect.long_effect16(from) & dir_mask;
		LongEffect.UPDATE_LONG_EFFECT_FROM_REWIND(pos,from,dir_bw_us,dir_bw_others,1);
	}
	static rewind_by_no_capturing_piece(pos,from,to,moved_pc,moved_after_pc) {
		let Us = pos.sideToMove;
		let board_effect = pos.board_effect;
		let long_effect = pos.long_effect;
		let inc_target = LongEffect.short_effects_from(moved_pc,from).newCOPY();
		let dec_target = LongEffect.short_effects_from(moved_after_pc,to).newCOPY();
		let and_target = inc_target.newAND(dec_target);
		inc_target.XOR(and_target);
		dec_target.XOR(and_target);
		while(inc_target.IsNonZero()) {
			let sq = inc_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Us,sq,1);
		}
		while(dec_target.IsNonZero()) {
			let sq = dec_target.PopLSB();
			LongEffect.ADD_BOARD_EFFECT_REWIND(pos,Us,sq,-1);
		}
		let dir_bw_us = LongEffect.long_effect16_of(moved_after_pc);
		let dir_bw_others = pos.long_effect.long_effect16(to);
		LongEffect.UPDATE_LONG_EFFECT_FROM_REWIND(pos,to,dir_bw_us,dir_bw_others,-1);
		let dir = Types.directions_of(from,to);
		let dir_mask;
		if(dir != 0) {
			let dir_cont = 1 << 7 - Bitboard.LeastSB(dir);
			dir_mask = ~(dir_cont | dir_cont << 8);
		} else {
			dir_mask = 65535;
		}
		dir_bw_us = LongEffect.long_effect16_of(moved_pc) & dir_mask;
		dir_bw_others = pos.long_effect.long_effect16(from) & dir_mask;
		LongEffect.UPDATE_LONG_EFFECT_FROM_REWIND(pos,from,dir_bw_us,dir_bw_others,1);
	}
	static effects_from(pc,sq,occ) {
		switch(pc) {
		case 1:
			return BB.pawnEffect(0,sq);
		case 2:
			return BB.lanceEffect(0,sq,occ);
		case 3:
			return BB.knightEffect(0,sq);
		case 4:
			return BB.silverEffect(0,sq);
		case 7:case 9:case 10:case 11:case 12:
			return BB.goldEffect(0,sq);
		case 13:case 29:
			return BB.horseEffect(sq,occ);
		case 17:
			return BB.pawnEffect(1,sq);
		case 18:
			return BB.lanceEffect(1,sq,occ);
		case 19:
			return BB.knightEffect(1,sq);
		case 20:
			return BB.silverEffect(1,sq);
		case 5:case 21:
			return BB.bishopEffect(sq,occ);
		case 6:case 22:
			return BB.rookEffect(sq,occ);
		case 8:case 24:
			return BB.kingEffect(sq);
		case 23:case 25:case 26:case 27:case 28:
			return BB.goldEffect(1,sq);
		case 14:case 30:
			return BB.dragonEffect(sq,occ);
		default:
			return new Bitboard();
		}
	}
	static ADD_BOARD_EFFECT_BOTH(pos,color_,sq_,e1_,e2_) {
		pos.board_effect[color_].e[sq_] += e1_;
		pos.board_effect[Types.OppColour(color_)].e[sq_] += e2_;
	}
	static ADD_BOARD_EFFECT_REWIND(pos,color_,sq_,e1_) {
		pos.board_effect[color_].e[sq_] += e1_;
	}
	static ADD_BOARD_EFFECT_BOTH_REWIND(pos,color_,sq_,e1_,e2_) {
		pos.board_effect[color_].e[sq_] += e1_;
		pos.board_effect[Types.OppColour(color_)].e[sq_] += e2_;
	}
}
LongEffect.__name__ = true;
Math.__name__ = true;
class MoveExt {
	constructor() {
		this.score = 0;
		this.move = 0;
	}
}
MoveExt.__name__ = true;
class MoveList {
	constructor() {
		this.moveCount = 0;
		this.curIndex = 0;
		this.mlist = [];
		let _g = 0;
		while(_g < 600) {
			let i = _g++;
			this.mlist[i] = new MoveExt();
		}
	}
	Reset() {
		this.curIndex = 0;
		this.moveCount = 0;
	}
	SerializeBR(from,b,us) {
		if(BB.squareBB[from].newAND(BB.enemyField3[us]).IsNonZero()) {
			b.NORM27();
			while(b.IsNonZero()) {
				let tmp = b.PopLSB();
				this.mlist[this.moveCount].move = Types.Make_Move_Promote(from,tmp);
				this.moveCount++;
			}
			return;
		}
		let pb = b.newAND(BB.enemyField3[us]);
		let nb = b.newAND(BB.enemyField3[us].newNOT());
		let to;
		pb.NORM27();
		while(pb.IsNonZero()) {
			to = pb.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move_Promote(from,to);
			this.moveCount++;
		}
		nb.NORM27();
		while(nb.IsNonZero()) {
			to = nb.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move(from,to);
			this.moveCount++;
		}
	}
	SerializeS(from,b,us) {
		let pb1 = new Bitboard();
		let to;
		if(BB.squareBB[from].newAND(BB.enemyField3[us]).IsNonZero()) {
			pb1.Copy(b);
			pb1.NORM27();
			while(pb1.IsNonZero()) {
				to = pb1.PopLSB();
				this.mlist[this.moveCount].move = Types.Make_Move_Promote(from,to);
				this.moveCount++;
			}
		}
		let pb2 = b.newAND(BB.enemyField3[us]);
		pb2.AND(pb1.newNOT());
		pb2.NORM27();
		while(pb2.IsNonZero()) {
			to = pb2.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move_Promote(from,to);
			this.moveCount++;
		}
		b.NORM27();
		while(b.IsNonZero()) {
			to = b.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move(from,to);
			this.moveCount++;
		}
	}
	SerializeN(from,b,us) {
		let pb = b.newAND(BB.enemyField3[us]).NORM27();
		let nb = b.newAND(BB.enemyField2[us].newNOT()).NORM27();
		let to;
		while(pb.IsNonZero()) {
			to = pb.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move_Promote(from,to);
			this.moveCount++;
		}
		while(nb.IsNonZero()) {
			to = nb.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move(from,to);
			this.moveCount++;
		}
	}
	SerializeL(from,b,us) {
		let pb = b.newAND(BB.enemyField3[us]).NORM27();
		let nb = b.newAND(BB.enemyField2[us].newNOT()).NORM27();
		let to;
		while(pb.IsNonZero()) {
			to = pb.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move_Promote(from,to);
			this.moveCount++;
		}
		while(nb.IsNonZero()) {
			to = nb.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move(from,to);
			this.moveCount++;
		}
	}
	SerializePawns(b,delta,us) {
		let pb = b.newAND(BB.enemyField3[us]).NORM27();
		let nb = b.newAND(BB.enemyField3[us].newNOT()).NORM27();
		let to = 0;
		while(pb.IsNonZero()) {
			to = pb.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move_Promote(to - delta,to);
			this.moveCount++;
		}
		while(nb.IsNonZero()) {
			to = nb.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move(to - delta,to);
			this.moveCount++;
		}
	}
	SerializeDrop(pt,b) {
		let to;
		b.NORM27();
		while(b.IsNonZero()) {
			to = b.PopLSB();
			let tmp = Types.RawTypeOf(pt);
			this.mlist[this.moveCount].move = Types.Make_Move_Drop(tmp,to);
			this.moveCount++;
		}
	}
	Serialize(from,b) {
		b.NORM27();
		while(b.IsNonZero()) {
			let tmp = b.PopLSB();
			this.mlist[this.moveCount].move = Types.Make_Move(from,tmp);
			this.moveCount++;
		}
	}
	GenerateMoves(pos,us,target,pt) {
		let pl = pos.PiecesColourType(us,pt).NORM27();
		let from = 0;
		let pc = Types.Make_Piece(us,pt);
		while(pl.IsNonZero()) {
			from = pl.PopLSB();
			let b = pos.AttacksFromPTypeSQ(from,pc).newAND(target);
			if(pt == 5 || pt == 6) {
				this.SerializeBR(from,b,us);
			} else if(pt == 4) {
				this.SerializeS(from,b,us);
			} else if(pt == 3) {
				this.SerializeN(from,b,us);
			} else if(pt == 2) {
				this.SerializeL(from,b,us);
			} else {
				this.Serialize(from,b);
			}
		}
	}
	GenerateKingMoves(pos,us,target) {
		this.GenerateMoves(pos,us,target,8);
	}
	generatePawnMoves(pos,us,target) {
		let up = 1;
		let tRank8BB = BB.ranksBB[8];
		if(us == 0) {
			up = -1;
			tRank8BB = BB.ranksBB[0];
		}
		let emptySquares = target;
		let pawnsNotOn7 = pos.PiecesColourType(us,1).newAND(tRank8BB.newNOT());
		let b1 = BB.ShiftBB(pawnsNotOn7,up).newAND(emptySquares);
		this.SerializePawns(b1,up,us);
	}
	GenerateDopMoves(pos,us,target,pt) {
		if(!pos.HandExists(us,Types.RawTypeOf(pt))) {
			return;
		}
		let target2 = target.newAND(pos.PiecesAll().newNOT());
		switch(pt) {
		case 1:
			target2.AND(BB.enemyField1[us].newNOT());
			target2.AND(BB.pawnLineBB[us].newNOT());
			break;
		case 2:
			target2.AND(BB.enemyField1[us].newNOT());
			break;
		case 3:
			target2.AND(BB.enemyField2[us].newNOT());
			break;
		default:
		}
		this.SerializeDrop(pt,target2);
	}
	GenerateAllDopMoves(pos,us,target) {
		this.GenerateDopMoves(pos,us,target,1);
		this.GenerateDopMoves(pos,us,target,2);
		this.GenerateDopMoves(pos,us,target,3);
		this.GenerateDopMoves(pos,us,target,4);
		this.GenerateDopMoves(pos,us,target,5);
		this.GenerateDopMoves(pos,us,target,6);
		this.GenerateDopMoves(pos,us,target,7);
	}
	GenerateAll(pos,us,target,genType) {
		if(genType != 0) {
			this.GenerateAllDopMoves(pos,us,target);
		}
		this.generatePawnMoves(pos,us,target);
		this.GenerateMoves(pos,us,target,2);
		this.GenerateMoves(pos,us,target,3);
		this.GenerateMoves(pos,us,target,4);
		this.GenerateMoves(pos,us,target,5);
		this.GenerateMoves(pos,us,target,6);
		this.GenerateMoves(pos,us,target,7);
		this.GenerateMoves(pos,us,target,9);
		this.GenerateMoves(pos,us,target,10);
		this.GenerateMoves(pos,us,target,11);
		this.GenerateMoves(pos,us,target,12);
		this.GenerateMoves(pos,us,target,13);
		this.GenerateMoves(pos,us,target,14);
		this.GenerateKingMoves(pos,us,target);
	}
	Generate(pos,genType) {
		let us = pos.SideToMove();
		let this1 = 0;
		let pt = this1;
		let this2 = 0;
		let pc = this2;
		if(genType == 4) {
			let target = pos.PiecesColour(us).newNOT();
			this.GenerateAll(pos,us,target,genType);
		}
		if(genType == 3) {
			let checkersCnt = 0;
			let ksq = pos.king_square(us);
			let checksq = 0;
			let sliderAttacks = new Bitboard();
			let b = new Bitboard();
			b.Copy(pos.Checkers());
			while(true) {
				++checkersCnt;
				checksq = b.PopLSB();
				pc = pos.piece_on(checksq);
				pt = Types.TypeOf_Piece(pc);
				if(pt == 5 || pt == 6 || pt == 13 || pt == 14 || pt == 2) {
					sliderAttacks.OR(BB.lineBB[checksq][ksq].newXOR(BB.squareBB[checksq]));
				}
				if(pt == 13 || pt == 14) {
					sliderAttacks.OR(BB.getStepAttacksBB(8,checksq));
				}
				if(!b.IsNonZero()) {
					break;
				}
			}
			b = new Bitboard();
			b.Copy(pos.AttacksFromPTypeSQ(ksq,8));
			b.AND(pos.PiecesColour(us).newNOT());
			b.AND(sliderAttacks.newNOT());
			this.Serialize(ksq,b);
			if(checkersCnt > 1) {
				return;
			}
			let target1 = BB.betweenBB[checksq][ksq].newCOPY();
			let target2 = target1.newOR(BB.squareBB[checksq]);
			this.generatePawnMoves(pos,us,target2);
			this.GenerateMoves(pos,us,target2,2);
			this.GenerateMoves(pos,us,target2,3);
			this.GenerateMoves(pos,us,target2,4);
			this.GenerateMoves(pos,us,target2,5);
			this.GenerateMoves(pos,us,target2,6);
			this.GenerateMoves(pos,us,target2,7);
			this.GenerateMoves(pos,us,target2,9);
			this.GenerateMoves(pos,us,target2,10);
			this.GenerateMoves(pos,us,target2,11);
			this.GenerateMoves(pos,us,target2,12);
			this.GenerateMoves(pos,us,target2,13);
			this.GenerateMoves(pos,us,target2,14);
			this.GenerateAllDopMoves(pos,us,target1);
		}
		if(genType == 5) {
			if(pos.Checkers().IsNonZero()) {
				this.Generate(pos,3);
			} else {
				this.Generate(pos,4);
			}
			let ksq = pos.king_square(pos.SideToMove());
			let i = 0;
			while(i < this.moveCount) if(Types.move_from(this.mlist[i].move) == ksq && pos.legal(this.mlist[i].move) == false) {
				this.moveCount--;
				this.mlist[i].move = this.mlist[this.moveCount].move;
			} else {
				++i;
			}
		}
	}
}
MoveList.__name__ = true;
class MovePicker {
	constructor() {
		this.generated = false;
		this.stage = 0;
		this.end = 0;
		this.cur = 0;
		this.moves = new MoveList();
	}
	InitA(p) {
		this.pos = p;
		this.moves.Reset();
		this.cur = 0;
		this.end = 0;
		if(p.in_check()) {
			this.stage = 6;
		} else {
			this.stage = 0;
		}
		this.GenerateNext();
	}
	InitB(p) {
		this.pos = p;
		this.moves.Reset();
		this.cur = 0;
		this.end = 0;
		this.stage = 6;
		let us = this.pos.SideToMove();
		let them = Types.OppColour(us);
		let ksq = this.pos.king_square(them);
		let target = this.pos.PiecesColour(them).newCOPY();
		target.SetBit(ksq);
		target.ClrBit(ksq);
		if(p.in_check()) {
			this.GenerateNext();
		} else {
			this.moves.GenerateAll(this.pos,us,target,0);
		}
	}
	GenerateNext() {
		this.cur = 0;
		if(this.stage == 6) {
			this.moves.Generate(this.pos,3);
		} else {
			this.moves.Generate(this.pos,5);
		}
		this.end = this.moves.moveCount;
		this.stage++;
	}
	next_move() {
		if(this.moves.moveCount == 0) {
			return 0;
		}
		let move = this.moves.mlist[this.cur].move;
		this.cur++;
		return move;
	}
}
MovePicker.__name__ = true;
class PSQTable {
}
PSQTable.__name__ = true;
class Position {
	constructor() {
		this.nodes = 0;
		this.evalList = new EvalList();
		this.long_effect = new WordBoard();
		this.board_effect = new Array(2);
		this.materialValue = 0;
		this.pieceList = [];
		this.pieceCount = [];
		this.index = [];
		this.byColorBB = [];
		this.byTypeBB = [];
		this.hand = [];
		this.sideToMove = 0;
		this.board = [];
		LongEffect.init(this);
		this.InitBB();
	}
	eval_list() {
		return this.evalList;
	}
	ADD_BOARD_EFFECT(c,to,e1) {
		this.board_effect[c].e[to] += e1;
	}
	InitBB() {
		this.byTypeBB = [];
		let _g = 0;
		let _g1 = 31;
		while(_g < _g1) {
			let i = _g++;
			this.byTypeBB.push(new Bitboard());
		}
		this.byColorBB = [];
		this.byColorBB.push(new Bitboard());
		this.pieceCount[0] = [];
		this.pieceList[0] = [];
		this.pieceCount[0][0] = 0;
		this.pieceList[0][0] = [];
		this.pieceCount[0][1] = 0;
		this.pieceList[0][1] = [];
		this.pieceCount[0][2] = 0;
		this.pieceList[0][2] = [];
		this.pieceCount[0][3] = 0;
		this.pieceList[0][3] = [];
		this.pieceCount[0][4] = 0;
		this.pieceList[0][4] = [];
		this.pieceCount[0][5] = 0;
		this.pieceList[0][5] = [];
		this.pieceCount[0][6] = 0;
		this.pieceList[0][6] = [];
		this.pieceCount[0][7] = 0;
		this.pieceList[0][7] = [];
		this.pieceCount[0][8] = 0;
		this.pieceList[0][8] = [];
		this.pieceCount[0][9] = 0;
		this.pieceList[0][9] = [];
		this.pieceCount[0][10] = 0;
		this.pieceList[0][10] = [];
		this.pieceCount[0][11] = 0;
		this.pieceList[0][11] = [];
		this.pieceCount[0][12] = 0;
		this.pieceList[0][12] = [];
		this.pieceCount[0][13] = 0;
		this.pieceList[0][13] = [];
		this.pieceCount[0][14] = 0;
		this.pieceList[0][14] = [];
		this.byColorBB.push(new Bitboard());
		this.pieceCount[1] = [];
		this.pieceList[1] = [];
		this.pieceCount[1][0] = 0;
		this.pieceList[1][0] = [];
		this.pieceCount[1][1] = 0;
		this.pieceList[1][1] = [];
		this.pieceCount[1][2] = 0;
		this.pieceList[1][2] = [];
		this.pieceCount[1][3] = 0;
		this.pieceList[1][3] = [];
		this.pieceCount[1][4] = 0;
		this.pieceList[1][4] = [];
		this.pieceCount[1][5] = 0;
		this.pieceList[1][5] = [];
		this.pieceCount[1][6] = 0;
		this.pieceList[1][6] = [];
		this.pieceCount[1][7] = 0;
		this.pieceList[1][7] = [];
		this.pieceCount[1][8] = 0;
		this.pieceList[1][8] = [];
		this.pieceCount[1][9] = 0;
		this.pieceList[1][9] = [];
		this.pieceCount[1][10] = 0;
		this.pieceList[1][10] = [];
		this.pieceCount[1][11] = 0;
		this.pieceList[1][11] = [];
		this.pieceCount[1][12] = 0;
		this.pieceList[1][12] = [];
		this.pieceCount[1][13] = 0;
		this.pieceList[1][13] = [];
		this.pieceCount[1][14] = 0;
		this.pieceList[1][14] = [];
		this.st = new StateInfo();
	}
	pawn_effect(sq,c) {
		return BB.stepAttacksBB[Types.Make_Piece(c,1)][sq];
	}
	AttackersToSq(sq) {
		return this.AttackersTo(sq,this.byTypeBB[0]);
	}
	Nodes() {
		return this.nodes;
	}
	Checkers() {
		return this.st.checkersBB;
	}
	in_check() {
		return this.Checkers().IsNonZero();
	}
	blockers_for_king(c) {
		return this.st.blockersForKing[c];
	}
	king_square(c) {
		return this.pieceList[c][8][0];
	}
	legal(m) {
		if(Types.is_drop(m)) {
			return true;
		}
		let us = this.sideToMove;
		let from = Types.move_from(m);
		if(Types.TypeOf_Piece(this.piece_on(from)) == 8) {
			if(!this.AttackersToSq(Types.move_to(m)).newAND(this.PiecesColour(Types.OppColour(us))).IsZero()) {
				return false;
			}
		}
		if(this.blockers_for_king(us).isSet(from)) {
			return Types.aligned(from,Types.to_sq(m),this.king_square(us));
		} else {
			return true;
		}
	}
	pieces() {
		return this.PiecesAll();
	}
	PiecesAll() {
		return this.byTypeBB[0];
	}
	PiecesColour(c) {
		return this.byColorBB[c];
	}
	PiecesColourType(c,pt) {
		return this.byColorBB[c].newAND(this.byTypeBB[pt]);
	}
	piece_on(sq) {
		let this1 = this.board[sq];
		return this1;
	}
	piecesType(pt) {
		return this.byTypeBB[pt];
	}
	between_bb(from,to) {
		return BB.betweenBB[from][to];
	}
	bona_piece_of(c,pt) {
		let ct = this.hand[c][pt];
		return this.evalList.kpp_hand_index[c][pt].fb + ct - 1;
	}
	piece_no_of_hand(c,pt) {
		return this.evalList.piece_no_of_hand(this.bona_piece_of(c,pt));
	}
	piece_no_of(sq) {
		return this.evalList.piece_no_of_board(sq);
	}
	PiecesTypes(pt1,pt2) {
		return this.byTypeBB[pt1].newOR(this.byTypeBB[pt2]);
	}
	changeSideToMove() {
		this.sideToMove = (this.sideToMove + 1) % 2;
	}
	set_check_info(si) {
		si.blockersForKing[1] = this.slider_blockers(0,this.king_square(1),si.pinners[1]);
		si.blockersForKing[0] = this.slider_blockers(1,this.king_square(0),si.pinners[0]);
	}
	slider_blockers(c,s,pinners) {
		let us = Types.OppColour(c);
		let blockers = new Bitboard();
		let rook_dragons = this.piecesType(6).newOR(this.piecesType(14)).newAND(BB.rookStepEffect(s));
		let bishop_horses = this.piecesType(5).newOR(this.piecesType(13)).newAND(BB.bishopStepEffect(s));
		let lances = this.piecesType(2).newAND(BB.lanceStepEffect(us,s));
		let snipers = rook_dragons.newOR(bishop_horses).newOR(lances).newAND(this.PiecesColour(c));
		while(snipers.IsNonZero()) {
			let sniperSq = snipers.PopLSB();
			let b = this.between_bb(s,sniperSq).newAND(this.PiecesAll());
			if(b.IsNonZero() && !b.more_than_one()) {
				blockers.OR(b);
				if(b.newAND(this.PiecesColour(us)).IsNonZero()) {
					pinners.SetBit(b.LSB());
				}
			}
		}
		return blockers;
	}
	countNode() {
		this.nodes++;
	}
	do_move(move,newSt) {
		this.doMoveFull(move,newSt);
	}
	doMoveFull(move,newSt) {
		let from = Types.move_from(move);
		let to = Types.move_to(move);
		let us = this.sideToMove;
		let them = Types.OppColour(us);
		let pc = this.MovedPieceAfter(move);
		let pr = Types.RawTypeOf(pc);
		let pt = Types.TypeOf_Piece(pc);
		let moved_after_pc;
		if(Types.Move_Type(move) == 32768) {
			let this1 = pc + 8;
			moved_after_pc = this1;
		} else {
			moved_after_pc = pc;
		}
		let materialDiff = 0;
		this.countNode();
		newSt.Copy(this.st);
		newSt.previous = this.st;
		this.st = newSt;
		if(Types.is_drop(move)) {
			this.st.dirtyPiece.dirty_num = 1;
			this.PutPiece(to,us,pt);
			let piece_no = this.piece_no_of(pr);
			this.evalList.put_piece(piece_no,to,pc);
			this.SubHand(us,pr);
			materialDiff = 0;
			LongEffect.update_by_dropping_piece(this,to,pc);
		} else {
			let capturedPC = this.piece_on(to);
			let captured = Types.TypeOf_Piece(capturedPC);
			let capturedRaw = Types.RawTypeOf(captured);
			if(captured != 0) {
				LongEffect.update_by_capturing_piece(this,from,to,pc,moved_after_pc,capturedPC);
				let capsq = to;
				let piece_no = this.piece_no_of(to);
				let this1 = pr;
				this.evalList.put_piece_hand(piece_no,us,this1,this.HandCount(us,pr));
				this.AddHand(us,capturedRaw);
				this.RemovePiece(capsq,them,captured);
			} else {
				LongEffect.update_by_no_capturing_piece(this,from,to,pc,moved_after_pc);
			}
			let piece_no2 = this.piece_no_of(from);
			this.RemovePiece(from,us,pt);
			this.MovePiece(from,to,us,pt);
			this.evalList.put_piece(piece_no2,to,pc);
			if(Types.Move_Type(move) == 32768) {
				this.RemovePiece(to,us,pt);
				let this1 = pt + 8;
				this.PutPiece(to,us,this1);
				materialDiff = Evaluate.proDiffPieceValue[pt];
			}
			this.st.capturedType = captured;
			materialDiff += Evaluate.capturePieceValue[captured];
			this.st.materialValue = this.st.previous.materialValue + (us == 0 ? materialDiff : -materialDiff);
		}
		let tmp = this.AttackersToSq(this.king_square(them));
		let tmp1 = this.PiecesColour(us);
		this.st.checkersBB = tmp.newAND(tmp1);
		this.changeSideToMove();
		this.set_check_info(this.st);
	}
	undo_move(move) {
		this.changeSideToMove();
		let us = this.sideToMove;
		let them = Types.OppColour(us);
		let to = Types.move_to(move);
		let pc = this.MovedPieceAfter(move);
		let pr = Types.RawTypeOf(pc);
		let pt = Types.TypeOf_Piece(this.piece_on(to));
		let moved_after_pc;
		if(Types.Move_Type(move) == 32768) {
			let this1 = pc + 8;
			moved_after_pc = this1;
		} else {
			moved_after_pc = pc;
		}
		if(Types.is_drop(move)) {
			this.AddHand(us,pr);
			this.RemovePiece(to,us,pt);
			LongEffect.rewind_by_dropping_piece(this,to,moved_after_pc);
		} else {
			let from = Types.move_from(move);
			let captured = this.st.capturedType;
			let to_pc = Types.Make_Piece(them,captured);
			let capturedRaw = Types.RawTypeOf(captured);
			if(Types.Move_Type(move) == 32768) {
				let promotion = pt;
				let this1 = pt - 8;
				pt = this1;
				this.RemovePiece(to,us,promotion);
				this.PutPiece(from,us,pt);
			} else {
				this.RemovePiece(to,us,pt);
				this.PutPiece(from,us,pt);
			}
			if(captured != 0) {
				let capsq = to;
				this.SubHand(us,capturedRaw);
				this.PutPiece(capsq,them,captured);
				LongEffect.rewind_by_capturing_piece(this,from,to,pc,moved_after_pc,to_pc);
			} else {
				LongEffect.rewind_by_no_capturing_piece(this,from,to,pc,moved_after_pc);
			}
		}
		this.st = this.st.previous;
	}
	PutPiece(sq,c,pt) {
		this.board[sq] = Types.Make_Piece(c,pt);
		this.byColorBB[c].SetBit(sq);
		this.byTypeBB[0].SetBit(sq);
		this.byTypeBB[pt].SetBit(sq);
		let tmp = this.pieceCount[c];
		tmp[0]++;
		let tmp1 = this.pieceCount[c];
		this.index[sq] = tmp1[pt]++;
		this.pieceList[c][pt][this.index[sq]] = sq;
		if(pt == 1) {
			BB.pawnLineBB[c].OR(BB.filesBB[Types.file_of(sq)]);
		}
	}
	MovePiece(from,to,c,pt) {
		this.board[to] = Types.Make_Piece(c,pt);
		this.board[from] = 0;
		this.byColorBB[c].SetBit(to);
		this.byTypeBB[0].SetBit(to);
		this.byTypeBB[pt].SetBit(to);
		this.index[to] = this.index[from];
		this.pieceList[c][pt][this.index[to]] = to;
		if(pt == 1) {
			BB.pawnLineBB[c].OR(BB.filesBB[Types.file_of(to)]);
		}
	}
	RemovePiece(sq,c,pt) {
		this.board[sq] = 0;
		this.byColorBB[c].ClrBit(sq);
		this.byTypeBB[0].ClrBit(sq);
		this.byTypeBB[pt].ClrBit(sq);
		let tmp = this.pieceCount[c];
		tmp[0]--;
		if(this.pieceCount[c][pt] > 0) {
			let tmp = this.pieceCount[c];
			tmp[pt]--;
		}
		let lastSquare = this.pieceList[c][pt][this.pieceCount[c][pt]];
		this.index[lastSquare] = this.index[sq];
		this.pieceList[c][pt][this.index[lastSquare]] = lastSquare;
		this.pieceList[c][pt][this.pieceCount[c][pt]] = 81;
		if(pt == 1) {
			BB.pawnLineBB[c].AND(BB.filesBB[Types.file_of(sq)].newNOT());
		}
	}
	HandExists(c,pr) {
		return this.hand[c][pr] > 0;
	}
	AddHand(c,pr,n) {
		if(n == null) {
			n = 1;
		}
		this.hand[c][pr] += n;
	}
	SubHand(c,pr,n) {
		if(n == null) {
			n = 1;
		}
		this.hand[c][pr] -= n;
	}
	HandCount(c,pr) {
		return this.hand[c][pr];
	}
	AttackersTo(s,occ) {
		let attBB = this.pawn_effect(s,0).newAND(this.PiecesColourType(1,1));
		attBB.OR(this.pawn_effect(s,1).newAND(this.PiecesColourType(0,1)));
		attBB.OR(this.AttacksFromPTypeSQ(s,19).newAND(this.PiecesColourType(0,3)));
		attBB.OR(this.AttacksFromPTypeSQ(s,3).newAND(this.PiecesColourType(1,3)));
		attBB.OR(this.AttacksFromPTypeSQ(s,18).newAND(this.PiecesColourType(0,2)));
		attBB.OR(this.AttacksFromPTypeSQ(s,2).newAND(this.PiecesColourType(1,2)));
		attBB.OR(this.AttacksFromPTypeSQ(s,20).newAND(this.PiecesColourType(0,4)));
		attBB.OR(this.AttacksFromPTypeSQ(s,4).newAND(this.PiecesColourType(1,4)));
		attBB.OR(this.AttacksFromPTypeSQ(s,23).newAND(this.PiecesColourType(0,7)));
		attBB.OR(this.AttacksFromPTypeSQ(s,7).newAND(this.PiecesColourType(1,7)));
		attBB.OR(this.AttacksFromPTypeSQ(s,25).newAND(this.PiecesColourType(0,9)));
		attBB.OR(this.AttacksFromPTypeSQ(s,9).newAND(this.PiecesColourType(1,9)));
		attBB.OR(this.AttacksFromPTypeSQ(s,26).newAND(this.PiecesColourType(0,10)));
		attBB.OR(this.AttacksFromPTypeSQ(s,10).newAND(this.PiecesColourType(1,10)));
		attBB.OR(this.AttacksFromPTypeSQ(s,27).newAND(this.PiecesColourType(0,11)));
		attBB.OR(this.AttacksFromPTypeSQ(s,11).newAND(this.PiecesColourType(1,11)));
		attBB.OR(this.AttacksFromPTypeSQ(s,28).newAND(this.PiecesColourType(0,12)));
		attBB.OR(this.AttacksFromPTypeSQ(s,12).newAND(this.PiecesColourType(1,12)));
		attBB.OR(BB.AttacksBB(s,occ,6).newAND(this.PiecesTypes(6,14)));
		attBB.OR(BB.AttacksBB(s,occ,5).newAND(this.PiecesTypes(5,13)));
		attBB.OR(this.AttacksFromPTypeSQ(s,8).newAND(this.PiecesTypes(14,13)));
		attBB.OR(this.AttacksFromPTypeSQ(s,8).newAND(this.piecesType(8)));
		return attBB;
	}
	MovedPieceAfter(m) {
		if(Types.is_drop(m)) {
			let this1 = m >>> 7 & 127;
			return this1;
		} else {
			return this.piece_on(Types.move_from(m));
		}
	}
	setPosition(sfen) {
		let piece_no_count = [0,0,18,22,26,34,36,30];
		this.InitBB();
		this.Clear();
		let sf = new SFEN(sfen);
		this.sideToMove = sf.SideToMove();
		this.board = sf.getBoard();
		let _g = 0;
		while(_g < 81) {
			let sq = _g++;
			let pc = this.piece_on(sq);
			let pt = Types.TypeOf_Piece(pc);
			let c = Types.getPieceColor(pc);
			if(pc == 0) {
				continue;
			}
			this.PutPiece(sq,c,pt);
			let piece_no;
			if(pc == 8) {
				piece_no = 38;
			} else if(pc == 24) {
				piece_no = 39;
			} else {
				let piece_no1 = Types.raw_type_of(pc);
				piece_no = piece_no_count[piece_no1]++;
			}
			this.evalList.put_piece(piece_no,sq,pc);
		}
		this.hand = sf.getHand();
		let _g1 = 0;
		let _g2 = this.hand[0][0];
		while(_g1 < _g2) {
			let i = _g1++;
			let piece_no = piece_no_count[0]++;
			let this1 = 0;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g3 = 0;
		let _g4 = this.hand[0][1];
		while(_g3 < _g4) {
			let i = _g3++;
			let piece_no = piece_no_count[1]++;
			let this1 = 1;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g5 = 0;
		let _g6 = this.hand[0][2];
		while(_g5 < _g6) {
			let i = _g5++;
			let piece_no = piece_no_count[2]++;
			let this1 = 2;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g7 = 0;
		let _g8 = this.hand[0][3];
		while(_g7 < _g8) {
			let i = _g7++;
			let piece_no = piece_no_count[3]++;
			let this1 = 3;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g9 = 0;
		let _g10 = this.hand[0][4];
		while(_g9 < _g10) {
			let i = _g9++;
			let piece_no = piece_no_count[4]++;
			let this1 = 4;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g11 = 0;
		let _g12 = this.hand[0][5];
		while(_g11 < _g12) {
			let i = _g11++;
			let piece_no = piece_no_count[5]++;
			let this1 = 5;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g13 = 0;
		let _g14 = this.hand[0][6];
		while(_g13 < _g14) {
			let i = _g13++;
			let piece_no = piece_no_count[6]++;
			let this1 = 6;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g15 = 0;
		let _g16 = this.hand[0][7];
		while(_g15 < _g16) {
			let i = _g15++;
			let piece_no = piece_no_count[7]++;
			let this1 = 7;
			this.evalList.put_piece_hand(piece_no,0,this1,i);
		}
		let _g17 = 0;
		let _g18 = this.hand[1][0];
		while(_g17 < _g18) {
			let i = _g17++;
			let piece_no = piece_no_count[0]++;
			let this1 = 0;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g19 = 0;
		let _g20 = this.hand[1][1];
		while(_g19 < _g20) {
			let i = _g19++;
			let piece_no = piece_no_count[1]++;
			let this1 = 1;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g21 = 0;
		let _g22 = this.hand[1][2];
		while(_g21 < _g22) {
			let i = _g21++;
			let piece_no = piece_no_count[2]++;
			let this1 = 2;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g23 = 0;
		let _g24 = this.hand[1][3];
		while(_g23 < _g24) {
			let i = _g23++;
			let piece_no = piece_no_count[3]++;
			let this1 = 3;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g25 = 0;
		let _g26 = this.hand[1][4];
		while(_g25 < _g26) {
			let i = _g25++;
			let piece_no = piece_no_count[4]++;
			let this1 = 4;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g27 = 0;
		let _g28 = this.hand[1][5];
		while(_g27 < _g28) {
			let i = _g27++;
			let piece_no = piece_no_count[5]++;
			let this1 = 5;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g29 = 0;
		let _g30 = this.hand[1][6];
		while(_g29 < _g30) {
			let i = _g29++;
			let piece_no = piece_no_count[6]++;
			let this1 = 6;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let _g31 = 0;
		let _g32 = this.hand[1][7];
		while(_g31 < _g32) {
			let i = _g31++;
			let piece_no = piece_no_count[7]++;
			let this1 = 7;
			this.evalList.put_piece_hand(piece_no,1,this1,i);
		}
		let moves = sf.getMoves();
		let _g33 = 0;
		let _g34 = moves.length;
		while(_g33 < _g34) {
			let i = _g33++;
			this.do_move(moves[i],new StateInfo());
		}
		let tmp = this.AttackersToSq(this.king_square(this.sideToMove));
		let tmp1 = this.PiecesColour(Types.OppColour(this.sideToMove));
		this.st.checkersBB = tmp.newAND(tmp1);
		LongEffect.calc_effect(this);
	}
	side_to_move() {
		return this.sideToMove;
	}
	SideToMove() {
		return this.sideToMove;
	}
	state() {
		return this.st;
	}
	AttacksFromPTypeSQ(sq,pc) {
		let pt = Types.TypeOf_Piece(pc);
		if(pt == 5 || pt == 6 || pt == 13 || pt == 14) {
			return BB.AttacksBB(sq,this.PiecesAll(),pt);
		} else if(pt == 2) {
			let rb = BB.AttacksBB(sq,this.PiecesAll(),6);
			let b = BB.getStepAttacksBB(pc,sq).newAND(rb);
			return b;
		} else {
			return BB.getStepAttacksBB(pc,sq);
		}
	}
	Clear() {
		this.nodes = 0;
		let _g = 0;
		while(_g < 81) {
			let i = _g++;
			this.board[i] = 0;
			this.index[i] = 0;
		}
		this.byTypeBB[0].Clear();
		this.byTypeBB[1].Clear();
		this.byTypeBB[2].Clear();
		this.byTypeBB[3].Clear();
		this.byTypeBB[4].Clear();
		this.byTypeBB[5].Clear();
		this.byTypeBB[6].Clear();
		this.byTypeBB[7].Clear();
		this.byTypeBB[8].Clear();
		this.byTypeBB[9].Clear();
		this.byTypeBB[10].Clear();
		this.byTypeBB[11].Clear();
		this.byTypeBB[12].Clear();
		this.byTypeBB[13].Clear();
		this.byTypeBB[14].Clear();
		this.byColorBB[0].Clear();
		this.pieceCount[0] = [];
		let _g1 = 0;
		while(_g1 < 15) {
			let j = _g1++;
			this.pieceCount[0][j] = 0;
			this.pieceList[0][j][0] = 0;
			this.pieceList[0][j][1] = 0;
			this.pieceList[0][j][2] = 0;
			this.pieceList[0][j][3] = 0;
			this.pieceList[0][j][4] = 0;
			this.pieceList[0][j][5] = 0;
			this.pieceList[0][j][6] = 0;
			this.pieceList[0][j][7] = 0;
			this.pieceList[0][j][8] = 0;
			this.pieceList[0][j][9] = 0;
			this.pieceList[0][j][10] = 0;
			this.pieceList[0][j][11] = 0;
			this.pieceList[0][j][12] = 0;
			this.pieceList[0][j][13] = 0;
			this.pieceList[0][j][14] = 0;
			this.pieceList[0][j][15] = 0;
		}
		this.byColorBB[1].Clear();
		this.pieceCount[1] = [];
		let _g2 = 0;
		while(_g2 < 15) {
			let j = _g2++;
			this.pieceCount[1][j] = 0;
			this.pieceList[1][j][0] = 0;
			this.pieceList[1][j][1] = 0;
			this.pieceList[1][j][2] = 0;
			this.pieceList[1][j][3] = 0;
			this.pieceList[1][j][4] = 0;
			this.pieceList[1][j][5] = 0;
			this.pieceList[1][j][6] = 0;
			this.pieceList[1][j][7] = 0;
			this.pieceList[1][j][8] = 0;
			this.pieceList[1][j][9] = 0;
			this.pieceList[1][j][10] = 0;
			this.pieceList[1][j][11] = 0;
			this.pieceList[1][j][12] = 0;
			this.pieceList[1][j][13] = 0;
			this.pieceList[1][j][14] = 0;
			this.pieceList[1][j][15] = 0;
		}
		let _g3 = 0;
		while(_g3 < 15) {
			let i = _g3++;
			let _g = 0;
			while(_g < 16) {
				let j = _g++;
				this.pieceList[1][i][j] = 81;
				this.pieceList[0][i][j] = 81;
			}
		}
	}
	printBoard(msg) {
		if(msg == null) {
			msg = "";
		}
		let s = "+++ printBoard +++ : " + msg;
		s += "\n";
		let f = 8;
		while(f >= 0) {
			let sq = Types.Square(f,0);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f;
		}
		s += "\n";
		let f1 = 8;
		while(f1 >= 0) {
			let sq = Types.Square(f1,1);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f1;
		}
		s += "\n";
		let f2 = 8;
		while(f2 >= 0) {
			let sq = Types.Square(f2,2);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f2;
		}
		s += "\n";
		let f3 = 8;
		while(f3 >= 0) {
			let sq = Types.Square(f3,3);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f3;
		}
		s += "\n";
		let f4 = 8;
		while(f4 >= 0) {
			let sq = Types.Square(f4,4);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f4;
		}
		s += "\n";
		let f5 = 8;
		while(f5 >= 0) {
			let sq = Types.Square(f5,5);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f5;
		}
		s += "\n";
		let f6 = 8;
		while(f6 >= 0) {
			let sq = Types.Square(f6,6);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f6;
		}
		s += "\n";
		let f7 = 8;
		while(f7 >= 0) {
			let sq = Types.Square(f7,7);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f7;
		}
		s += "\n";
		let f8 = 8;
		while(f8 >= 0) {
			let sq = Types.Square(f8,8);
			s += HxOverrides.substr("  " + this.board[sq],-3,null);
			--f8;
		}
		haxe_Log.trace(s,{ fileName : "Position.hx", lineNumber : 547, className : "Position", methodName : "printBoard"});
	}
	printHand() {
		haxe_Log.trace(this.hand,{ fileName : "Position.hx", lineNumber : 551, className : "Position", methodName : "printHand"});
	}
	printPieceNo() {
		this.evalList.printPieceNo();
	}
	static Init() {
		Position.psq[0] = [];
		Position.psq[1] = [];
		let _g = 0;
		let _g1 = 15;
		while(_g < _g1) {
			let pt = _g++;
			Position.psq[0][pt] = [];
			Position.psq[1][pt] = [];
			let v = Position.pieceValue[pt];
			let _g1 = 0;
			while(_g1 < 81) {
				let s = _g1++;
				let sFlip = Types.FlipSquare(s);
				Position.psq[0][pt][s] = v + PSQTable.psqT[pt][s];
				Position.psq[1][pt][sFlip] = -(v + PSQTable.psqT[pt][s]);
			}
		}
	}
}
Position.__name__ = true;
class SFEN {
	constructor(sfen) {
		this.moves = [];
		this.hand = [[0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0]];
		this.sideToMove = 0;
		this.board = [];
		this.setPosition(sfen);
	}
	getBoard() {
		let arr = [];
		let _g = 0;
		while(_g < 81) {
			let i = _g++;
			arr.push(this.board[i]);
		}
		return arr;
	}
	getHand() {
		return this.hand;
	}
	getMoves() {
		return this.moves;
	}
	SideToMove() {
		return this.sideToMove;
	}
	setPosition(sfen) {
		sfen = StringTools.replace(sfen,"startpos","lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1");
		sfen = StringTools.replace(sfen,"sfen ","");
		haxe_Log.trace("SFEN::setPosition",{ fileName : "SFEN.hx", lineNumber : 45, className : "SFEN", methodName : "setPosition", customParams : [sfen]});
		let tokens = sfen.split(" ");
		let f = 8;
		let r = 0;
		let promote = false;
		let i = 0;
		let token = "";
		let sq = 0;
		this.board = [];
		haxe_Log.trace(tokens,{ fileName : "SFEN.hx", lineNumber : 54, className : "SFEN", methodName : "setPosition"});
		let _g = 0;
		let _g1 = tokens[0].length;
		while(_g < _g1) {
			let i = _g++;
			let token = tokens[0].charAt(i);
			if(util_StringUtil.isNumberString(token)) {
				let _g = 0;
				let _g1 = Std.parseInt(token);
				while(_g < _g1) {
					let n = _g++;
					sq = f * 9 + r;
					this.board[sq] = 0;
					--f;
				}
			} else if(token == "+") {
				promote = true;
			} else if(token == "/") {
				f = 8;
				++r;
			} else {
				sq = f * 9 + r;
				let pc = Types.getPieceFromLabel(token);
				if(promote) {
					let this1 = pc + 8;
					pc = this1;
				}
				this.board[sq] = pc;
				--f;
				promote = false;
			}
		}
		this.sideToMove = tokens[1] == "b" ? 0 : 1;
		let ct = 0;
		let _g2 = 0;
		let _g3 = tokens[2].length;
		while(_g2 < _g3) {
			let i = _g2++;
			let token = tokens[2].charAt(i);
			if(token == "-") {
				break;
			} else if(util_StringUtil.isNumberString(token)) {
				ct = Std.parseInt(token) + ct * 10;
			} else {
				ct = util_MathUtil.max(ct,1);
				let pc = Types.getPieceFromLabel(token);
				this.hand[Types.getPieceColor(pc)][Types.RawTypeOf(pc)] = ct;
				ct = 0;
			}
		}
		if(sfen.indexOf("moves") > 0) {
			let mvs = sfen.split("moves ")[1].split(" ");
			let _g = 0;
			let _g1 = mvs.length;
			while(_g < _g1) {
				let i = _g++;
				let m = Types.generateMoveFromString(mvs[i]);
				this.moves.push(m);
			}
		}
	}
}
SFEN.__name__ = true;
class Signals {
}
Signals.__name__ = true;
class Search {
	constructor() {
	}
	static Init() {
		haxe_Log.trace("Search::Init",{ fileName : "Search.hx", lineNumber : 26, className : "Search", methodName : "Init"});
		let _g = 0;
		while(_g < 600) {
			let i = _g++;
			Search.rootMoves.push(new SearchRootMove());
		}
	}
	static Reset(pos) {
		haxe_Log.trace("Search::Reset",{ fileName : "Search.hx", lineNumber : 33, className : "Search", methodName : "Reset"});
		let _g = 0;
		while(_g < 600) {
			let i = _g++;
			Search.rootMoves[i].Clear();
		}
		Search.numRootMoves = 0;
		Search.rootPos = pos;
		let moves = new MoveList();
		moves.Generate(Search.rootPos,5);
		let _g1 = 0;
		let _g2 = moves.moveCount;
		while(_g1 < _g2) {
			let i = _g1++;
			Search.rootMoves[Search.numRootMoves].SetMove(moves.mlist[i].move);
			Search.numRootMoves++;
		}
	}
	static Think() {
		haxe_Log.trace("Search::Think",{ fileName : "Search.hx", lineNumber : 48, className : "Search", methodName : "Think"});
		Search.maxPly = 0;
		Search.rootColor = Search.rootPos.SideToMove();
		Evaluate.evalRootColour = Search.rootColor;
		Search.IDLoop(Search.rootPos);
	}
	static IDLoop(pos) {
		haxe_Log.trace("====================",{ fileName : "Search.hx", lineNumber : 56, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("Search::IDLoop start",{ fileName : "Search.hx", lineNumber : 57, className : "Search", methodName : "IDLoop"});
		let depth = 0;
		let bestValue = -30001;
		let alpha = -30001;
		let beta = 30001;
		let delta = 30001;
		Signals.stop = false;
		Signals.startTime = HxOverrides.now() / 1000;
		while(++depth < 6 && !Signals.stop) {
			haxe_Log.trace("Search::IDLoop depth=" + depth + " ",{ fileName : "Search.hx", lineNumber : 66, className : "Search", methodName : "IDLoop"});
			alpha = -30001;
			beta = 30001;
			bestValue = Search.Search(pos,alpha,beta,depth,0);
			Search.StableSort(Search.rootMoves,0,Search.numRootMoves - 1);
		}
		haxe_Log.trace("Search::IDLoop end",{ fileName : "Search.hx", lineNumber : 84, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 0 + " " + Types.Move_To_String(Search.rootMoves[0].pv[0]) + " " + Search.rootMoves[0].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 1 + " " + Types.Move_To_String(Search.rootMoves[1].pv[0]) + " " + Search.rootMoves[1].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 2 + " " + Types.Move_To_String(Search.rootMoves[2].pv[0]) + " " + Search.rootMoves[2].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 3 + " " + Types.Move_To_String(Search.rootMoves[3].pv[0]) + " " + Search.rootMoves[3].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 4 + " " + Types.Move_To_String(Search.rootMoves[4].pv[0]) + " " + Search.rootMoves[4].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 5 + " " + Types.Move_To_String(Search.rootMoves[5].pv[0]) + " " + Search.rootMoves[5].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 6 + " " + Types.Move_To_String(Search.rootMoves[6].pv[0]) + " " + Search.rootMoves[6].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 7 + " " + Types.Move_To_String(Search.rootMoves[7].pv[0]) + " " + Search.rootMoves[7].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 8 + " " + Types.Move_To_String(Search.rootMoves[8].pv[0]) + " " + Search.rootMoves[8].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 9 + " " + Types.Move_To_String(Search.rootMoves[9].pv[0]) + " " + Search.rootMoves[9].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 10 + " " + Types.Move_To_String(Search.rootMoves[10].pv[0]) + " " + Search.rootMoves[10].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 11 + " " + Types.Move_To_String(Search.rootMoves[11].pv[0]) + " " + Search.rootMoves[11].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 12 + " " + Types.Move_To_String(Search.rootMoves[12].pv[0]) + " " + Search.rootMoves[12].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 13 + " " + Types.Move_To_String(Search.rootMoves[13].pv[0]) + " " + Search.rootMoves[13].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 14 + " " + Types.Move_To_String(Search.rootMoves[14].pv[0]) + " " + Search.rootMoves[14].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 15 + " " + Types.Move_To_String(Search.rootMoves[15].pv[0]) + " " + Search.rootMoves[15].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 16 + " " + Types.Move_To_String(Search.rootMoves[16].pv[0]) + " " + Search.rootMoves[16].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 17 + " " + Types.Move_To_String(Search.rootMoves[17].pv[0]) + " " + Search.rootMoves[17].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 18 + " " + Types.Move_To_String(Search.rootMoves[18].pv[0]) + " " + Search.rootMoves[18].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 19 + " " + Types.Move_To_String(Search.rootMoves[19].pv[0]) + " " + Search.rootMoves[19].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 20 + " " + Types.Move_To_String(Search.rootMoves[20].pv[0]) + " " + Search.rootMoves[20].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 21 + " " + Types.Move_To_String(Search.rootMoves[21].pv[0]) + " " + Search.rootMoves[21].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 22 + " " + Types.Move_To_String(Search.rootMoves[22].pv[0]) + " " + Search.rootMoves[22].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 23 + " " + Types.Move_To_String(Search.rootMoves[23].pv[0]) + " " + Search.rootMoves[23].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 24 + " " + Types.Move_To_String(Search.rootMoves[24].pv[0]) + " " + Search.rootMoves[24].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 25 + " " + Types.Move_To_String(Search.rootMoves[25].pv[0]) + " " + Search.rootMoves[25].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 26 + " " + Types.Move_To_String(Search.rootMoves[26].pv[0]) + " " + Search.rootMoves[26].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 27 + " " + Types.Move_To_String(Search.rootMoves[27].pv[0]) + " " + Search.rootMoves[27].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 28 + " " + Types.Move_To_String(Search.rootMoves[28].pv[0]) + " " + Search.rootMoves[28].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		haxe_Log.trace("rootMoves" + 29 + " " + Types.Move_To_String(Search.rootMoves[29].pv[0]) + " " + Search.rootMoves[29].score,{ fileName : "Search.hx", lineNumber : 86, className : "Search", methodName : "IDLoop"});
		let elapsed = HxOverrides.now() / 1000 - Signals.startTime;
		let nps = pos.Nodes() / elapsed | 0;
		let ereg_r = new RegExp("\\B(?=(\\d\\d\\d)+(?!\\d))","g".split("u").join(""));
		haxe_Log.trace("nps:" + ("" + nps).replace(ereg_r,",") + " nodes :" + pos.Nodes() + " elapsed:" + elapsed,{ fileName : "Search.hx", lineNumber : 91, className : "Search", methodName : "IDLoop"});
	}
	static StableSort(moves,begin,end) {
		if(begin == end) {
			return;
		}
		let swapped = false;
		let this1 = 0;
		let m = this1;
		let s = 0;
		let _g = begin;
		let _g1 = end;
		while(_g < _g1) {
			let j = _g++;
			swapped = false;
			let i = end;
			while(i > j) {
				if(moves[i - 1].score < moves[i].score) {
					swapped = true;
					let tmp = moves[i - 1];
					moves[i - 1] = moves[i];
					moves[i] = tmp;
					m = moves[i].pv[0];
					s = moves[i].score;
				}
				--i;
			}
			if(!swapped) {
				break;
			}
		}
	}
	static Qsearch(pos,alpha,beta,depth) {
		let ply_from_root = (6 - depth / 1 | 0) + 1;
		let InCheck = pos.in_check();
		let value = 0;
		if(InCheck) {
			alpha = -30001;
			if(depth < -9) {
				return Evaluate.DoEvaluate(pos,false);
			}
		} else {
			value = Evaluate.DoEvaluate(pos,false);
			if(alpha < value) {
				alpha = value;
				if(alpha >= beta) {
					return alpha;
				}
			}
			if(depth < -9) {
				return alpha;
			}
		}
		let mp = new MovePicker();
		mp.InitB(pos);
		let move;
		let si = new StateInfo();
		while(true) {
			move = mp.next_move();
			if(!(move != 0)) {
				break;
			}
			if(!pos.legal(move)) {
				pos.countNode();
				continue;
			}
			pos.do_move(move,si);
			value = -Search.Qsearch(pos,-beta,-alpha,depth - 1);
			pos.undo_move(move);
			if(Signals.stop) {
				haxe_Log.trace("qsearch Signals.stop !",{ fileName : "Search.hx", lineNumber : 168, className : "Search", methodName : "Qsearch"});
				return 0;
			}
			if(value > alpha) {
				alpha = value;
				if(alpha >= beta) {
					return alpha;
				}
			}
		}
		if(InCheck && alpha == -30001) {
			return Types.mated_in(ply_from_root);
		}
		return alpha;
	}
	static Search(pos,alpha,beta,depth,nodeType) {
		let pvMove = true;
		let mp = new MovePicker();
		let this1 = 0;
		let move = this1;
		let rootNode = nodeType == 0;
		let value = 0;
		let st = new StateInfo();
		mp.InitA(pos);
		while(true) {
			move = mp.next_move();
			if(!(move != 0)) {
				break;
			}
			if(!pos.legal(move)) {
				pos.countNode();
				continue;
			}
			pos.do_move(move,st);
			value = depth - 1 < 1 ? -Search.Qsearch(pos,-beta,-alpha,depth) : -Search.Search(pos,-beta,-alpha,depth - 1,2);
			pos.undo_move(move);
			if(Signals.stop) {
				haxe_Log.trace("search Signals.stop !",{ fileName : "Search.hx", lineNumber : 211, className : "Search", methodName : "Search"});
				return 0;
			}
			let sa = HxOverrides.now() / 1000 - Signals.startTime;
			if(sa > 5) {
				haxe_Log.trace("Time Over ...",{ fileName : "Search.hx", lineNumber : 216, className : "Search", methodName : "Search"});
				Signals.stop = true;
				return 0;
			}
			if(rootNode) {
				let rm;
				let _g = 0;
				let _g1 = Search.numRootMoves;
				while(_g < _g1) {
					let k = _g++;
					if(Search.rootMoves[k].Equals(move)) {
						rm = Search.rootMoves[k];
						rm.score = value;
						break;
					}
				}
			}
			if(value > alpha) {
				alpha = value;
				if(alpha >= beta) {
					break;
				}
			}
		}
		return alpha;
	}
}
Search.__name__ = true;
class SearchRootMove {
	constructor() {
		this.pv = [];
	}
	Clear() {
		this.score = 0;
		this.prevScore = 0;
		this.pv[0] = 0;
		this.numMoves = 0;
	}
	SetMove(m) {
		this.score = -30001;
		this.prevScore = -30001;
		this.pv[0] = m;
		this.numMoves = 1;
	}
	Equals(m) {
		return this.pv[0] == m;
	}
}
SearchRootMove.__name__ = true;
class StateInfo {
	constructor() {
		this.sum = new EvalSum();
		this.dirtyPiece = new DirtyPiece();
		this.materialValue = 0;
		this.capturedType = 0;
		this.pinners = new Array(2);
		this.blockersForKing = new Array(2);
		this.checkersBB = new Bitboard();
		this.blockersForKing[0] = new Bitboard();
		this.pinners[0] = new Bitboard();
		this.blockersForKing[1] = new Bitboard();
		this.pinners[1] = new Bitboard();
	}
	Clear() {
		this.checkersBB.Clear();
		let this1 = 0;
		this.capturedType = this1;
		this.materialValue = 0;
		this.dirtyPiece = new DirtyPiece();
		this.checkersBB = new Bitboard();
		this.blockersForKing[0] = new Bitboard();
		this.pinners[0] = new Bitboard();
		this.blockersForKing[1] = new Bitboard();
		this.pinners[1] = new Bitboard();
		this.previous = null;
		this.sum = new EvalSum();
	}
	Copy(other) {
		this.checkersBB.Copy(other.checkersBB);
		this.capturedType = other.capturedType;
		this.materialValue = other.materialValue;
		this.previous = other.previous;
		this.blockersForKing[0].Copy(other.blockersForKing[0]);
		this.pinners[0].Copy(other.pinners[0]);
		this.blockersForKing[1].Copy(other.blockersForKing[1]);
		this.pinners[1].Copy(other.pinners[1]);
	}
}
StateInfo.__name__ = true;
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		if(x != null) {
			let _g = 0;
			let _g1 = x.length;
			while(_g < _g1) {
				let i = _g++;
				let c = x.charCodeAt(i);
				if(c <= 8 || c >= 14 && c != 32 && c != 45) {
					let nc = x.charCodeAt(i + 1);
					let v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
					if(isNaN(v)) {
						return null;
					} else {
						return v;
					}
				}
			}
		}
		return null;
	}
}
Std.__name__ = true;
class StringTools {
	static replace(s,sub,by) {
		return s.split(sub).join(by);
	}
}
StringTools.__name__ = true;
class Move {
	static _new(i) {
		let this1 = i;
		return this1;
	}
}
class PR {
	static _new(i) {
		let this1 = i;
		return this1;
	}
}
class PT {
	static _new(i) {
		let this1 = i;
		return this1;
	}
}
class PC {
	static _new(i) {
		let this1 = i;
		return this1;
	}
}
class Types {
	static sqww_to_sq(sqww) {
		return sqww & 255;
	}
	static to_sqww(sq) {
		return Types.sqww_table[sq];
	}
	static to_directions(d) {
		return 1 << d;
	}
	static is_ok(sqww) {
		return (sqww & 277094400) == 0;
	}
	static DirectToDeltaWW(d) {
		return Types.DirectToDeltaWW_[d];
	}
	static directions_of(sq1,sq2) {
		return Types.direc_table[sq1][sq2];
	}
	static aligned(sq1,sq2,sq3) {
		return BB.ANDsq(BB.lineBB[sq1][sq2],sq3).IsNonZero();
	}
	static Inv(sq) {
		return 80 - sq;
	}
	static mated_in(ply) {
		return -30000 + ply;
	}
	static has_long_effect(pc) {
		if(Types.type_of(pc) != 2) {
			return (pc + 1 & 6) == 6;
		} else {
			return true;
		}
	}
	static OppColour(c) {
		return c ^ 1;
	}
	static Is_SqOK(s) {
		if(s >= 0) {
			return s <= 80;
		} else {
			return false;
		}
	}
	static file_of(s) {
		return Types.SquareToFile[s];
	}
	static rank_of(s) {
		return Types.SquareToRank[s];
	}
	static dist(sq1,sq2) {
		if(!Types.is_ok(sq1) || !Types.is_ok(sq2)) {
			return 2147483647;
		} else {
			return util_MathUtil.max(util_MathUtil.abs(Types.file_of(sq1) - Types.file_of(sq2)),util_MathUtil.abs(Types.rank_of(sq1) - Types.rank_of(sq2)));
		}
	}
	static FileString_Of(s) {
		return "" + (Types.file_of(s) + 1);
	}
	static File_To_Char(f) {
		return "" + (f + 1);
	}
	static Rank_To_Char(r,toLower) {
		if(toLower == null) {
			toLower = true;
		}
		if(toLower) {
			let code = HxOverrides.cca("a",0) + r;
			return String.fromCodePoint(code);
		} else {
			let code = HxOverrides.cca("A",0) + r;
			return String.fromCodePoint(code);
		}
	}
	static Square_To_String(s) {
		return Types.File_To_Char(Types.file_of(s)) + Types.Rank_To_Char(Types.rank_of(s));
	}
	static Char_To_File(n) {
		return Std.parseInt(n) - 1;
	}
	static Char_To_Rank(a) {
		return HxOverrides.cca(a,0) - 97;
	}
	static move_from(m) {
		return m >>> 7 & 127;
	}
	static to_sq(m) {
		return Types.move_to(m);
	}
	static move_to(m) {
		return m & 127;
	}
	static Move_Dropped_Piece(m) {
		let this1 = m >>> 7 & 127;
		return this1;
	}
	static Move_Type(m) {
		return m & 49152;
	}
	static Move_To_String(m) {
		if(Types.is_drop(m)) {
			let this1 = Types.Move_Dropped_Piece(m);
			let pc = Types.PieceToChar(this1);
			let str = Types.Square_To_String(Types.move_to(m));
			return "" + pc + "*" + str;
		} else if(Types.Is_Promote(m)) {
			return Types.Square_To_String(Types.move_from(m)) + Types.Square_To_String(Types.move_to(m)) + "+";
		} else {
			return Types.Square_To_String(Types.move_from(m)) + Types.Square_To_String(Types.move_to(m));
		}
	}
	static Move_To_StringLong(m) {
		return Types.Move_To_String(m) + " " + Types.Move_Type_String(m) + " : " + m;
	}
	static Move_Type_String(m) {
		if(Types.Move_Type(m) == 16384) {
			return "Drop";
		}
		if(Types.Move_Type(m) == 32768) {
			return "Promo";
		}
		return "Normal";
	}
	static Make_Move(from,to) {
		let this1 = to | from << 7;
		return this1;
	}
	static Make_Move_Promote(from,to) {
		let this1 = to | from << 7 | 32768;
		return this1;
	}
	static Make_Move_Drop(pr,sq) {
		let this1 = sq | pr << 7 | 16384;
		return this1;
	}
	static generateMoveFromString(ft) {
		let f = Types.Char_To_File(ft.charAt(0));
		let r = Types.Char_To_Rank(ft.charAt(1));
		let from = Types.Square(f,r);
		f = Types.Char_To_File(ft.charAt(2));
		r = Types.Char_To_Rank(ft.charAt(3));
		let to = Types.Square(f,r);
		if(ft.indexOf("*") > 0) {
			let pr = Types.RawTypeOf(Types.getPieceFromLabel(ft.charAt(0)));
			f = Types.Char_To_File(ft.charAt(2));
			r = Types.Char_To_Rank(ft.charAt(3));
			to = Types.Square(f,r);
			return Types.Make_Move_Drop(pr,to);
		} else if(ft.indexOf("+") > 0) {
			return Types.Make_Move_Promote(from,to);
		} else {
			return Types.Make_Move(from,to);
		}
	}
	static Is_Move_OK(m) {
		return Types.move_from(m) != Types.move_to(m);
	}
	static Is_Promote(m) {
		return (m & 32768) != 0;
	}
	static is_drop(m) {
		return (m & 16384) != 0;
	}
	static RankString_Of(s) {
		let code = 97 + Types.rank_of(s);
		return String.fromCodePoint(code);
	}
	static type_of(pc) {
		let this1 = pc & 15;
		return this1;
	}
	static raw_type_of(p) {
		return Types.RawTypeOf(p);
	}
	static RawTypeOf(p) {
		let this1 = p % 8;
		return this1;
	}
	static Make_Piece(c,pt) {
		let this1 = c << 4 | pt;
		return this1;
	}
	static Square(f,r) {
		return f * 9 + r;
	}
	static FlipSquare(sq) {
		return Types.flipSquare[sq];
	}
	static color_of(pc) {
		return (pc & 16) >> 4;
	}
	static getPieceColor(pc) {
		if(pc == 0) {
			return -1;
		}
		if((pc | 0) < 16) {
			return 0;
		} else {
			return 1;
		}
	}
	static TypeOf_Piece(pc) {
		let this1 = pc % 16;
		return this1;
	}
	static PieceToChar(pc) {
		if(pc == 1) {
			return "P";
		}
		if(pc == 2) {
			return "L";
		}
		if(pc == 4) {
			return "S";
		}
		if(pc == 3) {
			return "N";
		}
		if(pc == 5) {
			return "B";
		}
		if(pc == 6) {
			return "R";
		}
		if(pc == 7) {
			return "G";
		}
		if(pc == 8) {
			return "K";
		}
		if(pc == 9) {
			return "+P";
		}
		if(pc == 10) {
			return "+L";
		}
		if(pc == 11) {
			return "+N";
		}
		if(pc == 12) {
			return "+S";
		}
		if(pc == 13) {
			return "+B";
		}
		if(pc == 14) {
			return "+R";
		}
		if(pc == 17) {
			return "p";
		}
		if(pc == 18) {
			return "l";
		}
		if(pc == 19) {
			return "n";
		}
		if(pc == 20) {
			return "s";
		}
		if(pc == 21) {
			return "b";
		}
		if(pc == 22) {
			return "r";
		}
		if(pc == 23) {
			return "g";
		}
		if(pc == 24) {
			return "k";
		}
		if(pc == 25) {
			return "+p";
		}
		if(pc == 26) {
			return "+l";
		}
		if(pc == 27) {
			return "+n";
		}
		if(pc == 28) {
			return "+s";
		}
		if(pc == 29) {
			return "+b";
		}
		if(pc == 30) {
			return "+r";
		}
		return "?";
	}
	static getPieceFromLabel(token) {
		switch(token) {
		case "B":
			return 5;
		case "G":
			return 7;
		case "K":
			return 8;
		case "L":
			return 2;
		case "N":
			return 3;
		case "P":
			return 1;
		case "R":
			return 6;
		case "S":
			return 4;
		case "b":
			return 21;
		case "g":
			return 23;
		case "k":
			return 24;
		case "l":
			return 18;
		case "n":
			return 19;
		case "p":
			return 17;
		case "r":
			return 22;
		case "s":
			return 20;
		default:
			return 0;
		}
	}
	static getPieceLabel(pt) {
		switch((pt | 0) % 16) {
		case 0:
			return "";
		case 1:
			return "";
		case 2:
			return "";
		case 3:
			return "";
		case 4:
			return "";
		case 5:
			return "";
		case 6:
			return "";
		case 7:
			return "";
		case 8:
			return "";
		case 9:
			return "";
		case 10:
			return "";
		case 11:
			return "";
		case 12:
			return "";
		case 13:
			return "";
		case 14:
			return "";
		default:
			return "";
		}
	}
}
Types.__name__ = true;
class haxe_Log {
	static formatOutput(v,infos) {
		let str = Std.string(v);
		if(infos == null) {
			return str;
		}
		let pstr = infos.fileName + ":" + infos.lineNumber;
		if(infos.customParams != null) {
			let _g = 0;
			let _g1 = infos.customParams;
			while(_g < _g1.length) {
				let v = _g1[_g];
				++_g;
				str += ", " + Std.string(v);
			}
		}
		return pstr + ": " + str;
	}
	static trace(v,infos) {
		let str = haxe_Log.formatOutput(v,infos);
		if(typeof(console) != "undefined" && console.log != null) {
			console.log(str);
		}
	}
}
haxe_Log.__name__ = true;
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = true;
class js_Boot {
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
}
js_Boot.__name__ = true;
class util_MathUtil {
	static abs(a) {
		if(a >= 0) {
			return a;
		} else {
			return -a;
		}
	}
	static max(a,b) {
		if(a > b) {
			return a;
		} else {
			return b;
		}
	}
	static min(a,b) {
		if(a < b) {
			return a;
		} else {
			return b;
		}
	}
}
util_MathUtil.__name__ = true;
class util_StringUtil {
	static isNumberString(s) {
		let r = new EReg("[0-9]+","");
		return r.match(s);
	}
}
util_StringUtil.__name__ = true;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.__name__ = true;
Array.__name__ = true;
js_Boot.__toStr = ({ }).toString;
Bitboard.NA = 27;
Bitboard.NB = 54;
BB.ZERO_BB = new Bitboard();
BB.squareDistance = [];
BB.stepAttacksBB = [];
BB.betweenBB = [];
BB.lineBB = [];
BB.squareBB = [];
BB.enemyField1 = [];
BB.enemyField2 = [];
BB.enemyField3 = [];
BB.pawnLineBB = [];
BB.pseudoAttacks = [];
BB.pseudoQueenAttacks = [];
BB.RookStepEffectBB = [];
BB.BishopStepEffectBB = [];
BB.LanceStepEffectBB = [[]];
BB.initialized = false;
BB.steps = [[0,0,0,0,0,0,0,0,0],[-1,0,0,0,0,0,0,0,0],[-1,-2,-3,-4,-5,-6,-7,-8,0],[7,-11,0,0,0,0,0,0,0],[-1,8,10,-10,-8,0,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0],[-1,8,9,1,-10,-9,0,0,0],[-1,8,9,1,-10,-9,10,-8,0],[-1,8,9,1,-10,-9,0,0,0],[-1,8,9,1,-10,-9,0,0,0],[-1,8,9,1,-10,-9,0,0,0],[-1,8,9,1,-10,-9,0,0,0],[0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0]];
BB.rDeltas = [-1,-9,1,9];
BB.bDeltas = [-10,-8,10,8];
BB.fDeltas = [-1,1,0,0];
BB.nDeltas = [-1,0,0,0];
BB.sDeltas = [1,0,0,0];
Engine.global = eval("self");
EvalList.MAX_LENGTH = 40;
Evaluate.evalRootColour = 0;
Evaluate.pieceValue = [0,90,315,405,495,855,990,540,15000,540,540,540,540,945,1395,0,0,-90,-315,-405,-495,-855,-990,-540,-15000,-540,-540,-540,-540,-945,-1395];
Evaluate.capturePieceValue = [0,180,630,810,990,1710,1980,1080,15000,630,855,945,1035,1800,2385,0,0,180,630,810,990,1710,1980,1080,15000,630,855,945,1035,1800,2385];
Evaluate.proDiffPieceValue = [0,450,225,135,45,90,405,0,0];
Evaluate.FV_SCALE = 32;
Evaluate.our_effect_value = (function($this) {
	var $r;
	let this1 = new Array(9);
	$r = this1;
	return $r;
}(this));
Evaluate.their_effect_value = (function($this) {
	var $r;
	let this1 = new Array(9);
	$r = this1;
	return $r;
}(this));
LongEffect.le16 = (function($this) {
	var $r;
	let this1 = new Array(82);
	$r = this1;
	return $r;
}(this));
LongEffect.BISHOP_DIR = 32 | 128 | 1 | 4;
LongEffect.ROOK_DIR = 2 | 8 | 16 | 64;
LongEffect.long_effect16_table = [0,0,8,0,0,LongEffect.BISHOP_DIR,LongEffect.ROOK_DIR,0,0,0,0,0,0,LongEffect.BISHOP_DIR,LongEffect.ROOK_DIR,0,0,0,16 << 8,0,0,LongEffect.BISHOP_DIR << 8,LongEffect.ROOK_DIR << 8,0,0,0,0,0,0,LongEffect.BISHOP_DIR << 8,LongEffect.ROOK_DIR << 8,0];
MoveList.CAPTURES = 0;
MoveList.QUIETS = 1;
MoveList.QUIET_CHECKS = 2;
MoveList.EVASIONS = 3;
MoveList.NON_EVASIONS = 4;
MoveList.LEGAL = 5;
MovePicker.MAIN_SEARCH = 0;
MovePicker.CAPTURES_S1 = 1;
MovePicker.KILLERS_S1 = 2;
MovePicker.QUIETS_1_S1 = 3;
MovePicker.QUIETS_2_S1 = 4;
MovePicker.BAD_CAPTURES_S1 = 5;
MovePicker.EVASION = 6;
MovePicker.EVASIONS_S2 = 7;
MovePicker.QSEARCH_0 = 8;
MovePicker.CAPTURES_S3 = 9;
MovePicker.QUIET_CHECKS_S3 = 10;
MovePicker.QSEARCH_1 = 11;
MovePicker.CAPTURES_S4 = 12;
MovePicker.PROBCUT = 13;
MovePicker.CAPTURES_S5 = 14;
MovePicker.RECAPTURE = 15;
MovePicker.CAPTURES_S6 = 16;
MovePicker.STOP = 17;
PSQTable.psqT = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]];
Position.psq = [];
Position.pieceValue = [0,90,315,405,495,855,990,540,15000,540,540,540,540,945,1395];
SFEN.startpos = "lnsgkgsnl/1r5b1/ppppppppp/9/9/9/PPPPPPPPP/1B5R1/LNSGKGSNL b - 1";
Signals.stop = false;
Signals.startTime = 0;
Search.NodeRoot = 0;
Search.NodePV = 1;
Search.NodeNonPV = 2;
Search.rootMoves = [];
Search.numRootMoves = 0;
Search.rootColor = 0;
Search.maxPly = 0;
Search.pvSize = 1;
Search.MAX_DEPTH = -9;
Types.INT32_MAX = 2147483647;
Types.INT_MAX = 2147483647;
Types.VALUE_NOT_EVALUATED = 2147483647;
Types.ONE_PLY = 1;
Types.BLACK = 0;
Types.WHITE = 1;
Types.COLOR_NB = 2;
Types.ALL_PIECES = 0;
Types.PIECE_TYPE_NB = 15;
Types.PIECE_PROMOTE = 8;
Types.PIECE_WHITE = 16;
Types.PIECE_HAND_NB = 8;
Types.NO_PIECE_TYPE = 0;
Types.PAWN = 1;
Types.LANCE = 2;
Types.KNIGHT = 3;
Types.SILVER = 4;
Types.BISHOP = 5;
Types.ROOK = 6;
Types.GOLD = 7;
Types.KING = 8;
Types.PRO_PAWN = 9;
Types.PRO_LANCE = 10;
Types.PRO_KNIGHT = 11;
Types.PRO_SILVER = 12;
Types.HORSE = 13;
Types.DRAGON = 14;
Types.NO_PIECE = 0;
Types.B_PAWN = 1;
Types.B_LANCE = 2;
Types.B_KNIGHT = 3;
Types.B_SILVER = 4;
Types.B_BISHOP = 5;
Types.B_ROOK = 6;
Types.B_GOLD = 7;
Types.B_KING = 8;
Types.B_PRO_PAWN = 9;
Types.B_PRO_LANCE = 10;
Types.B_PRO_KNIGHT = 11;
Types.B_PRO_SILVER = 12;
Types.B_HORSE = 13;
Types.B_DRAGON = 14;
Types.W_PAWN = 17;
Types.W_LANCE = 18;
Types.W_KNIGHT = 19;
Types.W_SILVER = 20;
Types.W_BISHOP = 21;
Types.W_ROOK = 22;
Types.W_GOLD = 23;
Types.W_KING = 24;
Types.W_PRO_PAWN = 25;
Types.W_PRO_LANCE = 26;
Types.W_PRO_KNIGHT = 27;
Types.W_PRO_SILVER = 28;
Types.W_HORSE = 29;
Types.W_DRAGON = 30;
Types.PIECE_NB = 31;
Types.SQ_11 = 0;
Types.SQ_HB = 80;
Types.SQ_NB = 81;
Types.SQ_NB_PLUS1 = 82;
Types.SQ_NONE = 81;
Types.FILE_1 = 0;
Types.FILE_2 = 1;
Types.FILE_3 = 2;
Types.FILE_4 = 3;
Types.FILE_5 = 4;
Types.FILE_6 = 5;
Types.FILE_7 = 6;
Types.FILE_8 = 7;
Types.FILE_9 = 8;
Types.FILE_NB = 9;
Types.RANK_1 = 0;
Types.RANK_2 = 1;
Types.RANK_3 = 2;
Types.RANK_4 = 3;
Types.RANK_5 = 4;
Types.RANK_6 = 5;
Types.RANK_7 = 6;
Types.RANK_8 = 7;
Types.RANK_9 = 8;
Types.RANK_NB = 9;
Types.MAX_MOVES = 600;
Types.MAX_PLY = 6;
Types.DELTA_N = -1;
Types.DELTA_E = -9;
Types.DELTA_S = 1;
Types.DELTA_W = 9;
Types.DELTA_NN = -2;
Types.DELTA_NE = -10;
Types.DELTA_SE = -8;
Types.DELTA_SS = 2;
Types.DELTA_SW = 10;
Types.DELTA_NW = 8;
Types.SQ_D = 1;
Types.SQ_R = -9;
Types.SQ_U = -1;
Types.SQ_L = 9;
Types.MOVE_NONE = 0;
Types.MOVE_NORMAL = 0;
Types.MOVE_DROP = 16384;
Types.MOVE_PROMO = 32768;
Types.VALUE_ZERO = 0;
Types.VALUE_DRAW = 0;
Types.VALUE_KNOWN_WIN = 15000;
Types.VALUE_MATE = 30000;
Types.VALUE_INFINITE = 30001;
Types.VALUE_NONE = 30002;
Types.PawnValue = 90;
Types.LanceValue = 315;
Types.KnightValue = 405;
Types.SilverValue = 495;
Types.GoldValue = 540;
Types.BishopValue = 855;
Types.RookValue = 990;
Types.ProPawnValue = 540;
Types.ProLanceValue = 540;
Types.ProKnightValue = 540;
Types.ProSilverValue = 540;
Types.HorseValue = 945;
Types.DragonValue = 1395;
Types.KingValue = 15000;
Types.flipSquare = [80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0];
Types.bbToSquare = [72,63,54,45,36,27,18,9,0,73,64,55,46,37,28,19,10,1,74,65,56,47,38,29,20,11,2,75,66,57,48,39,30,21,12,3,76,67,58,49,40,31,22,13,4,77,68,59,50,41,32,23,14,5,78,69,60,51,42,33,24,15,6,79,70,61,52,43,34,25,16,7,80,71,62,53,44,35,26,17,8];
Types.SquareToFile = [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,9];
Types.SquareToRank = [0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,0,1,2,3,4,5,6,7,8,9];
Types.sqww_table = [];
Types.direc_table = [[]];
Types.DirectToDeltaWW_ = [17284598,16776695,16268792,507903,-507903,-16268792,-16776695,-17284598];
Engine.main();
})({});
